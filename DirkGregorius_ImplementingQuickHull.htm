<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
<title>DirkGregorius_ImplementingQuickHull</title>
<meta http-equiv="content-type" content="text/html; charset=utf-8">
<link rel="stylesheet" type="text/css" href="1.css">
<script type="text/javascript" src="1.js"></script>
</head>
<body>
<a href="https://www.gamedev.net/profile/30524-dirk-gregorius/?tab=activity"><img src="img/Dirk_Gregorius.png" width=150 border=0 align="left" alt="Dirk Gregorius" style="margin-top:-20px;"></a>
<div style="color:#000080; margin-left:220px;"><a href="https://www.gamedev.net/profile/30524-dirk-gregorius/?tab=activity">Dirk Gregorius</a></div>

<h1 style="margin-top:20px; margin-left:200px; margin-bottom:40px;">–†–µ–∞–ª–∏–∑–∞—Ü–∏—è –±—ã—Å—Ç—Ä–æ–≥–æ –∞–ª–≥–æ—Ä–∏—Ç–º–∞ –≤—ã–ø—É–∫–ª–æ–π –æ–±–æ–ª–æ—á–∫–∏<br>
<span style="font-size:70%; margin-left:20px;">Implementing&nbsp;QuickHull</span></h1><br><br>
–î–æ–±—Ä—ã–π –¥–µ–Ω—å! –ú–µ–Ω—è –∑–æ–≤—É—Ç –î–∏—Ä–∫, –∏ —è –∏–Ω–∂–µ–Ω–µ—Ä-–ø—Ä–æ–≥—Ä–∞–º–º–∏—Å—Ç –≤ Valve.<br><br>
–ù–µ–∫–æ—Ç–æ—Ä—ã–µ –∏–∑ –≤–∞—Å –≤–æ–∑–º–æ–∂–Ω–æ –∑–∞–º–µ—Ç–∏–ª–∏, —á—Ç–æ —è –∏–∑–º–µ–Ω–∏–ª –∑–∞–≥–æ–ª–æ–≤–æ–∫ —Å–≤–æ–µ–π –ª–µ–∫—Ü–∏–∏ –Ω–∞: "–†–µ–∞–ª–∏–∑–∞—Ü–∏—è –∞–ª–≥–æ—Ä–∏—Ç–º–∞ –≤—ã–ø—É–∫–ª–æ–π –æ–±–æ–ª–æ—á–∫–∏".<br>
–ö–æ–≥–¥–∞ —è –ø–µ—Ä–µ—Å–∫–∞–∑—ã–≤–∞–ª —ç—Ç—É –ª–µ–∫—Ü–∏—è –≤ Valve, –æ–¥–Ω–∏–º –∏–∑ –≤–æ–ø—Ä–æ—Å–æ–≤ –±—ã–ª: "–ü–æ—á–µ–º—É –ø—Ä–µ–∑–µ–Ω—Ç–∞—Ü–∏—è –æ –≤—ã–ø—É–∫–ª–æ–π –æ–±–æ–ª–æ—á–∫–µ? –†–∞–∑–≤–µ —ç—Ç–æ –Ω–µ —Ö–æ—Ä–æ—à–æ –ø–æ–Ω–∏–º–∞–µ–º—ã–π –∞–ª–≥–æ—Ä–∏—Ç–º?"<br>

–ù–∞ –º–æ–π –≤–∑–≥–ª—è–¥ —ç—Ç–æ –æ—Ç—á–∞—Å—Ç–∏ –≤–µ—Ä–Ω–æ. –ú–æ–∂–Ω–æ –Ω–∞–π—Ç–∏ –Ω–µ—Å–∫–æ–ª—å–∫–æ –ø—Ä–µ–∑–µ–Ω—Ç–∞—Ü–∏–π –æ–± –æ—Å–Ω–æ–≤–∞—Ö —Ç–µ–æ—Ä–∏–∏ –≤—ã–ø—É–∫–ª–æ–π –æ–±–æ–ª–æ—á–∫–∏ –∏ –∞–Ω–∞–ª–∏—Ç–∏—á–µ—Å–∫–∏—Ö —Å—Ç–∞—Ç–µ–π –Ω–µ–∫–æ—Ç–æ—Ä–æ–π —Å–ª–æ–∂–Ω–æ—Å—Ç–∏, –Ω–æ –≤—Ä—è–¥ –ª–∏
—ç—Ç–æ –≤—Å–µ –∏–º–µ–ª–æ –æ—Ç–Ω–æ—à–µ–Ω–∏–µ –∫ —Ä–µ–∞–ª–∏–∑–∞—Ü–∏–∏ –¥–∞–Ω–Ω–æ–≥–æ –∞–ª–≥–æ—Ä–∏—Ç–º–∞.
–û—Å–æ–±–µ–Ω–Ω–æ –≤ –ø—Ä–æ–∏–∑–≤–æ–¥—Å—Ç–≤–µ–Ω–Ω–æ–π —Å—Ä–µ–¥–µ, –≥–¥–µ –ø—Ä–∏—Ö–æ–¥–∏—Ç—Å—è –∏–º–µ—Ç—å –¥–µ–ª–æ —Å–æ –≤—Å–µ–º–∏ –≤–∏–¥–∞–º–∏ –Ω–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–Ω–æ–π –≤—Ö–æ–¥–Ω–æ–π –≥–µ–æ–º–µ—Ç—Ä–∏–µ–π!
–¢–∞–∫ —á—Ç–æ, —ç—Ç–∞ –ª–µ–∫—Ü–∏—è –±—É–¥–µ—Ç –æ—Ö–≤–∞—Ç—ã–≤–∞—Ç—å, –∫–æ–Ω–µ—á–Ω–æ –∂–µ, –æ—Å–Ω–æ–≤–Ω—É—é —Ç–µ–æ—Ä–∏—é Quickhull, –Ω–æ —Ç–∞–∫–∂–µ –ø–æ—Ç—Ä–∞—Ç–∏–º –º–Ω–æ–≥–æ –≤—Ä–µ–º–µ–Ω–∏ –Ω–∞ –∏–∑—É—á–µ–Ω–∏–µ –ø—Ä–æ–±–ª–µ–º, —Å –∫–æ—Ç–æ—Ä—ã–º–∏ –≤—ã –º–æ–∂–µ—Ç–µ —Å—Ç–æ–ª–∫–Ω—É—Ç—å—Å—è –ø—Ä–∏ —Ä–µ–∞–ª–∏–∑–∞—Ü–∏–∏ Quickhull, –∏ —Å–ø–æ—Å–æ–±–∞—Ö –∏—Ö —Ä–µ—à–µ–Ω–∏—è.<br><br>


<h2>–ü–ª–∞–Ω –ª–µ–∫—Ü–∏–∏</h2>
–í–Ω–∞—á–∞–ª–µ —Ö–æ—Ç–µ–ª–æ—Å—å –±—ã –±—ã—Å—Ç—Ä–æ –∏–∑–ª–æ–∂–∏—Ç—å –ø–ª–∞–Ω –ª–µ–∫—Ü–∏–∏:
<div class=blockindent>&nbsp; &#9679; &nbsp; –ü–æ—Å–ª–µ –∫–æ—Ä–æ—Ç–∫–æ–≥–æ –≤—Å—Ç—É–ø–ª–µ–Ω–∏—è —Å–Ω–∞—á–∞–ª–∞ –±—É–¥–µ—Ç —Ä–∞–∑–≥–æ–≤–æ—Ä –æ–± –∞–ª–≥–æ—Ä–∏—Ç–º–µ –≤—ã–ø—É–∫–ª–æ–π –æ–±–æ–ª–æ—á–∫–∏ (Quickhull) –≤ –¥–≤—É–º–µ—Ä–Ω–æ–º –ø—Ä–æ—Å—Ç—Ä–∞–Ω—Å—Ç–≤–µ.</div>
<div class=blockindent>&nbsp; &#9679; &nbsp; –ó–∞—Ç–µ–º –ø—Ä–æ–¥–æ–ª–∂–∏–º –æ–ø–∏—Å–∞–Ω–∏–µ —Å –≥–µ–æ–º–µ—Ç—Ä–∏—á–µ—Å–∫–∏–º–∏ –ø–æ—Å—Ç–æ—è–Ω–Ω—ã–º–∏ (–∏–Ω–≤–∞—Ä–∏–∞–Ω—Ç–∞–º–∏), –∫–æ—Ç–æ—Ä—ã–µ –Ω—É–∂–Ω–æ –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞—Ç—å –ø—Ä–∏ –ø–æ—Å—Ç—Ä–æ–µ–Ω–∏–∏ –æ–±–æ–ª–æ—á–∫–∏, –≤–æ –∏–∑–±–µ–∂–∞–Ω–∏–µ –≤—ã—á–∏—Å–ª–∏—Ç–µ–ª—å–Ω—ã—Ö –ø—Ä–æ–±–ª–µ–º. Then we continue with geometrical invariants which we need to maintain while constructing the hull to avoid numerical problems</div>
<div class=blockindent>&nbsp; &#9679; &nbsp; –ü–æ—Å–ª–µ –∑–Ω–∞–∫–æ–º—Å—Ç–≤–∞ —Å –¥–≤—É–º–µ—Ä–Ω—ã–º –≤–∞—Ä–∏–∞–Ω—Ç–æ–º, —Ç—É—Ç –∂–µ –ø–æ–≥—Ä—É–∂–∞–µ–º—Å—è –≤ —Ç—Ä–µ—Ö–º–µ—Ä–Ω—É—é –≤–µ—Ä—Å–∏—é –±—ã—Å—Ç—Ä–æ–π –æ–±–æ–ª–æ—á–∫–∏.</div>
<div class=blockindent>&nbsp; &#9679; &nbsp; –ó–∞—Ç–µ–º –∏—Å—Å–ª–µ–¥—É–µ–º –≥–µ–æ–º–µ—Ç—Ä–∏—á–µ—Å–∫–∏–µ –∏ —Ç–æ–ø–æ–ª–æ–≥–∏—á–µ—Å–∫–∏–µ –∏–Ω–≤–∞—Ä–∏–∞–Ω—Ç—ã –ø—Ä–∏ –ø–æ—Å—Ç—Ä–æ–µ–Ω–∏–∏ –æ–±–æ–ª–æ—á–∫–∏ –≤ —Ç—Ä–µ—Ö–º–µ—Ä–Ω–æ–º –ø—Ä–æ—Å—Ç—Ä–∞–Ω—Å—Ç–≤–µ –∏
We then investigate geometrical and topological invariants while constructing the hull in 3D and close with some implementation details.</div><br>

<h3>–í—ã–ø—É–∫–ª–æ—Å—Ç—å</h3>
–ü—Ä–µ–∂–¥–µ —á–µ–º –Ω–∞—á–∞—Ç—å, –¥–∞–≤–∞–π—Ç–µ –≤—ã—è—Å–Ω–∏–º, —á—Ç–æ —Ç–∞–∫–æ–µ –≤—ã–ø—É–∫–ª–∞—è –æ–±–æ–ª–æ—á–∫–∞ –∏ —Ä–∞—Å—Å–º–æ—Ç—Ä–∏–º –ø—Ä–∏–º–µ—Ä:
<div class=blockindent>&nbsp; &#9679; &nbsp; –§–∏–≥—É—Ä–∞ –Ω–∞–∑—ã–≤–∞–µ—Ç—Å—è –≤—ã–ø—É–∫–ª–æ–π, –µ—Å–ª–∏ –¥–ª—è –ª—é–±—ã—Ö –¥–≤—É—Ö —Ç–æ—á–µ–∫, –∫–æ—Ç–æ—Ä—ã–µ –Ω–∞—Ö–æ–¥—è—Ç—Å—è <b>–≤–Ω—É—Ç—Ä–∏</b> —Ñ–∏–≥—É—Ä—ã, –ª–∏–Ω–∏—è –º–µ–∂–¥—É —ç—Ç–∏–º–∏ –¥–≤—É–º—è —Ç–æ—á–∫–∞–º–∏ —Ç–∞–∫–∂–µ –Ω–∞—Ö–æ–¥–∏—Ç—Å—è –≤–Ω—É—Ç—Ä–∏.</div>
<div class=blockindent>&nbsp; &#9679; &nbsp; –ï—Å–ª–∏ –ø–æ—Å–º–æ—Ç—Ä–µ—Ç—å –Ω–∞ —Å–ª—É—á–∞–π —Å –≤–æ–≥–Ω—É—Ç–æ–π —Ñ–∏–≥—É—Ä–æ–π, —Ç–æ –ª–µ–≥–∫–æ –º–æ–∂–Ω–æ –Ω–∞–π—Ç–∏ –≤–Ω—É—Ç—Ä–∏ —Ñ–∏–≥—É—Ä—ã –¥–≤–µ —Ç–æ—á–∫–∏, –ª–∏–Ω–∏—è –º–µ–∂–¥—É –∫–æ—Ç–æ—Ä—ã–º–∏ –≤—ã—Ö–æ–¥–∏—Ç –∑–∞ –∫–æ–Ω—Ç—É—Ä —Ñ–∏–≥—É—Ä—ã –∏ –∑–∞—Ç–µ–º —Å–Ω–æ–≤–∞ –≤—Ö–æ–¥–∏—Ç –≤ –Ω–µ—ë.</div>
<table width=90%><tr><td width=50%><div class="caption"><img src="img/1a.png" width=250><br>–í—ã–ø—É–∫–ª–∞—è —Ñ–∏–≥—É—Ä–∞ (convex)</div></td>
<td width=50%><div class="caption"><img src="img/1b.png" width=250><br>–í–æ–≥–Ω—É—Ç–∞—è —Ñ–∏–≥—É—Ä–∞ (concave)</div></td></tr></table><br><br>

<h3>–í—ã–ø—É–∫–ª—ã–µ –æ–±–æ–ª–æ—á–∫–∏</h3>
–ß—Ç–æ —Ç–∞–∫–æ–µ –≤—ã–ø—É–∫–ª–∞—è –æ–±–æ–ª–æ—á–∫–∞ (convex hull)?<br>
–ó–∞–¥–∞–≤ –Ω–∞–±–æ—Ä –∏–∑ —ç–Ω–Ω–æ–≥–æ —á–∏—Å–ª–∞ –≤—Ö–æ–¥–Ω—ã—Ö —Ç–æ—á–µ–∫ –º–æ–∂–Ω–æ –æ–ø—Ä–µ–¥–µ–ª–∏—Ç—å, —á—Ç–æ –º–æ–∂–Ω–æ –Ω–∞–∑—ã–≤–∞—Ç—å –≤—ã–ø—É–∫–ª–æ–π –æ–±–æ–ª–æ—á–∫–æ–π:
<div class=blockindent>&nbsp; &#9679; &nbsp; –û—Ñ–∏—Ü–∏–∞–ª—å–Ω–æ–µ –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ: –≤—ã–ø—É–∫–ª–∞—è –æ–±–æ–ª–æ—á–∫–∞ —ç—Ç–æ –Ω–∞–∏–º–µ–Ω—å—à–∏–π –≤—ã–ø—É–∫–ª—ã–π –Ω–∞–±–æ—Ä, —Å–æ–¥–µ—Ä–∂–∞—â–∏–π –≤—Å–µ –≤—Ö–æ–¥–Ω—ã–µ —Ç–æ—á–∫–∏.</div>
<div class=blockindent>&nbsp; &#9679; &nbsp; –ü–æ –ø—Ä–æ—Å—Ç–æ–º—É: –ï—Å–ª–∏ –≤—Å–µ —Ç–æ—á–∫–∏ –ø—Ä–µ–¥—Å—Ç–∞–≤–∏—Ç—å –≤ –≤–∏–¥–µ –≥–≤–æ–∑–¥–µ–π, –≤–±–∏—Ç—ã—Ö –≤ –¥–µ—Ä–µ–≤—è–Ω–Ω—É—é –¥–æ—â–µ—á–∫—É, —Ç–æ –≤—ã–ø—É–∫–ª–∞—è –æ–±–æ–ª–æ—á–∫–∞ –±—É–¥–µ—Ç —Ä–µ–∑–∏–Ω–∫–æ–π, –Ω–∞—Ç—è–Ω—É—Ç–æ–π –≤–æ–∫—Ä—É–≥ –≤–Ω–µ—à–Ω–∏—Ö –≥–≤–æ–∑–¥–µ–π.</div>
<div class="caption"><img src="img/2.png" width=250><br>–ù–∞–±–æ—Ä —Ç–æ—á–µ–∫ –≤ –¥–≤—É–º–µ—Ä–Ω–æ–º –ø—Ä–æ—Å—Ç—Ä–∞–Ω—Å—Ç–≤–µ –∏ –µ–≥–æ –≤—ã–ø—É–∫–ª–∞—è –æ–±–æ–ª–æ—á–∫–∞</div><br>
<b>–≠—Ç–æ –æ–∑–Ω–∞—á–∞–µ—Ç, —á—Ç–æ –≤ –¥–≤—É–º–µ—Ä–Ω–æ–º –ø—Ä–æ—Å—Ç—Ä–∞–Ω—Å—Ç–≤–µ –æ–±–æ–ª–æ—á–∫–æ–π —è–≤–ª—è–µ—Ç—Å—è –º–Ω–æ–≥–æ—É–≥–æ–ª—å–Ω–∏–∫ (–ø–æ–ª–∏–≥–æ–Ω), –æ–ø—Ä–µ–¥–µ–ª—è–µ–º—ã–π –≤–µ—Ä—à–∏–Ω–∞–º–∏ –∏ —Ä–µ–±—Ä–∞–º–∏!</b><br><br>

–¢–∞–∫–∂–µ —Ö–æ—á–µ—Ç—Å—è –ø–æ–∫–∞–∑–∞—Ç—å —Ç—Ä–µ—Ö–º–µ—Ä–Ω—É—é –≤—ã–ø—É–∫–ª—É—é –æ–±–æ–ª–æ—á–∫—É –≤–æ–∫—Ä—É–≥ —Ö–æ—Ä–æ—à–æ –∏–∑–≤–µ—Å—Ç–Ω–æ–≥–æ –æ–±—ä–µ–∫—Ç–∞ - —á–∞–π–Ω–∏–∫–∞ –Æ—Ç–∞ (Utah Teapot).
<div class=blockindent>&nbsp; &#9679; &nbsp; –í –¥–≤—É–º–µ—Ä–Ω–æ–º –ø—Ä–æ—Å—Ç—Ä–∞–Ω—Å—Ç–≤–µ –¥–ª—è –ø–æ–ª—É—á–µ–Ω–∏—è –Ω–µ–∫–æ–µ–≥–æ –ø–æ–Ω–∏–º–∞–Ω–∏—è –æ –≤—ã–ø—É–∫–ª–æ–π –æ–±–æ–ª–æ—á–∫–µ –≤ –∫–∞—á–µ—Å—Ç–≤–µ –∞–Ω–∞–ª–æ–≥–∞ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–ª–æ—Å—å –∫–æ–ª—å—Ü–æ —Ä–µ–∑–∏–Ω–∫–∏.</div>
<div class=blockindent>&nbsp; &#9679; &nbsp; –í —Ç—Ä–µ—Ö–º–µ—Ä–Ω–æ–º –ø—Ä–æ—Å—Ç—Ä–∞–Ω—Å—Ç–≤–µ –≤—ã–ø—É–∫–ª—É—é –æ–±–æ–ª–æ—á–∫—É –º–æ–∂–Ω–æ —Ä–∞—Å—Å–º–∞—Ç—Ä–∏–≤–∞—Ç—å –∫–∞–∫ —É–ø–∞–∫–æ–≤–∫—É –æ–±—ä–µ–∫—Ç–∞ –ø–ª–æ—Ç–Ω–æ –æ–±—Ç—è–≥–∏–≤–∞—é—â–µ–π –ø–ª–µ–Ω–∫–æ–π.</div>
<div class="caption"><img src="img/3.png" width=600></div><br>
<b>–í —Ç—Ä–µ—Ö–º–µ—Ä–Ω–æ–º –ø—Ä–æ—Å—Ç—Ä–∞–Ω—Å—Ç–≤–µ –æ–±–æ–ª–æ—á–∫–æ–π —è–≤–ª—è–µ—Ç—Å—è –º–Ω–æ–≥–æ–≥—Ä–∞–Ω–Ω–∏–∫, –æ–ø—Ä–µ–¥–µ–ª—è–µ–º—ã–π –≤–µ—Ä—à–∏–Ω–∞–º–∏, —Ä–µ–±—Ä–∞–º–∏ –∏ –º–Ω–æ–≥–æ—É–≥–æ–ª—å–Ω—ã–º–∏ (–ø–æ–ª–∏–≥–æ–Ω–∞–ª—å–Ω—ã–º–∏) –≥—Ä–∞–Ω—è–º–∏! –û–±—Ä–∞—Ç–∏—Ç–µ –≤–Ω–∏–º–∞–Ω–∏–µ, —á—Ç–æ –º—ã –Ω–µ —Å–æ–±–∏—Ä–∞–µ–º—Å—è –æ–≥—Ä–∞–Ω–∏—á–∏–≤–∞—Ç—å—Å—è —Ç–æ–ª—å–∫–æ —Ç—Ä–µ—É–≥–æ–ª—å–Ω—ã–º–∏ –≥—Ä–∞–Ω—è–º–∏!</b><br><br>

<h4>–ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ –≤—ã–ø—É–∫–ª—ã—Ö –æ–±–æ–ª–æ—á–µ–∫ –¥–ª—è –æ–±–Ω–∞—Ä—É–∂–µ–Ω–∏—è —Å—Ç–æ–ª–∫–Ω–æ–≤–µ–Ω–∏–π</h4>
–ü–æ—á–µ–º—É —Å–ª–µ–¥—É–µ—Ç –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –≤—ã–ø—É–∫–ª—ã–µ –æ–±–æ–ª–æ—á–∫–∏ –¥–ª—è –æ–±–Ω–∞—Ä—É–∂–µ–Ω–∏—è —Å—Ç–æ–ª–∫–Ω–æ–≤–µ–Ω–∏–π –≤ –∏–≥—Ä–∞—Ö?
<div class=blockindent>&nbsp; &#9679; &nbsp; –î–∏–Ω–∞–º–∏—á–µ—Å–∫–∏–µ –æ–±—ä–µ–∫—Ç—ã –≤ –∏–≥—Ä–∞—Ö –∏—Å–ø–æ–ª—å–∑—É—é—Ç –ø—Ä–∏–±–ª–∏–∂–µ–Ω–∏–µ –∫ –ø—Ä–æ—Å—Ç—ã–º —Ñ–æ—Ä–º–∞–º –¥–ª—è –æ–±–Ω–∞—Ä—É–∂–µ–Ω–∏—è —Å—Ç–æ–ª–∫–Ω–æ–≤–µ–Ω–∏–π –ø–æ—Å–∫–æ–ª—å–∫—É –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏—è –≥–µ–æ–º–µ—Ç—Ä–∏—á–µ—Å–∫–æ–≥–æ —ç–ª–µ–º–µ–Ω—Ç–∞ <b>–Ω–µ –±—É–¥–µ—Ç</b> —ç—Ñ—Ñ–µ–∫—Ç–∏–≤–Ω—ã–º —Å —Ç–æ—á–∫–∏ –∑—Ä–µ–Ω–∏—è –ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç–∏.</div>
<div class=blockindent>&nbsp; &#9679; &nbsp; –í—ã–ø—É–∫–ª—ã–µ –æ–±–æ–ª–æ—á–∫–∏ - —Ö–æ—Ä–æ—à–∏–π –∫–∞–Ω–¥–∏–¥–∞—Ç –Ω–∞ –∑–∞–º–µ–Ω—É, –ø–æ—Å–∫–æ–ª—å–∫—É –æ–Ω–∏ –º–æ–≥—É—Ç –¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ —Ö–æ—Ä–æ—à–æ —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤–æ–≤–∞—Ç—å –¥–∞–∂–µ —Å–ª–æ–∂–Ω–æ–º—É –≥–µ–æ–º–µ—Ç—Ä–∏—á–µ—Å–∫–æ–º—É —ç–ª–µ–º–µ–Ω—Ç—É.</div>
<div class=blockindent>&nbsp; &#9679; &nbsp; –ö—Ä–æ–º–µ —Ç–æ–≥–æ, –æ–±–Ω–∞—Ä—É–∂–µ–Ω–∏–µ —Å—Ç–æ–ª–∫–Ω–æ–≤–µ–Ω–∏–π –¥–ª—è –≤—ã–ø—É–∫–ª—ã—Ö –º–Ω–æ–≥–æ–≥—Ä–∞–Ω–Ω–∏–∫–æ–≤ —Ö–æ—Ä–æ—à–æ –∏ –Ω–∞–¥–µ–∂–Ω–æ –æ–ø—Ä–µ–¥–µ–ª—è–µ—Ç—Å—è. –í—Å–ø–æ–º–Ω–∏—Ç–µ –æ <a href="https://ru.wikipedia.org/wiki/%D0%90%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC_%D0%93%D0%B8%D0%BB%D0%B1%D0%B5%D1%80%D1%82%D0%B0_%E2%80%94_%D0%94%D0%B6%D0%BE%D0%BD%D1%81%D0%BE%D0%BD%D0%B0_%E2%80%94_%D0%9A%D1%91%D1%80%D1%82%D0%B8" onmouseover="show('GJK - —Å–æ–∫—Ä–∞—â. –æ—Ç –∞–Ω–≥–ª. —Å–ª–æ–≤ Gilbert‚ÄîJohnson‚ÄîKeerthi algorithm<br>(–∞–ª–≥–æ—Ä–∏—Ç–º –ì–∏–ª–±–µ—Ä—Ç–∞‚Äî–î–∂–æ–Ω—Å–æ–Ω–∞‚Äî–ö—ë—Ä—Ç–∏) ‚Äî –∞–ª–≥–æ—Ä–∏—Ç–º –¥–ª—è<br>–æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏—è –º–∏–Ω–∏–º–∞–ª—å–Ω–æ–≥–æ —Ä–∞—Å—Å—Ç–æ—è–Ω–∏—è –º–µ–∂–¥—É –¥–≤—É–º—è<br>–≤—ã–ø—É–∫–ª—ã–º–∏ –º–Ω–æ–∂–µ—Å—Ç–≤–∞–º–∏ (–æ–±—ä–µ–∫—Ç–∞–º–∏)')" onmouseout="hide()">GJK</a> –∏
<a href="https://ru.wikipedia.org/wiki/%D0%A2%D0%B5%D0%BE%D1%80%D0%B5%D0%BC%D0%B0_%D0%BE%D0%B1_%D0%BE%D0%BF%D0%BE%D1%80%D0%BD%D0%BE%D0%B9_%D0%B3%D0%B8%D0%BF%D0%B5%D1%80%D0%BF%D0%BB%D0%BE%D1%81%D0%BA%D0%BE%D1%81%D1%82%D0%B8" onmouseover="show('SAT - —Å–æ–∫—Ä–∞—â. –æ—Ç –∞–Ω–≥–ª. —Å–ª–æ–≤ Separating Axis Theorem<br>(—Ç–µ–æ—Ä–µ–º–∞ —Ä–∞–∑–¥–µ–ª—è—é—â–µ–π –æ—Å–∏) –¥–ª—è –¥–≤—É—Ö –≤—ã–ø—É–∫–ª—ã—Ö –æ–±—ä–µ–∫—Ç–æ–≤<br>–º–æ–∂–Ω–æ —Å—Ñ–æ—Ä–º—É–ª–∏—Ä–æ–≤–∞—Ç—å —Ç–∞–∫: –¥–≤–∞ –≤—ã–ø—É–∫–ª—ã—Ö –æ–±—ä–µ–∫—Ç–∞<br>–ø–µ—Ä–µ—Å–µ–∫–∞—é—Ç—Å—è —Ç–æ–≥–¥–∞ –∏ —Ç–æ–ª—å–∫–æ —Ç–æ–≥–¥–∞, –∫–æ–≥–¥–∞ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç<br>–ø–ª–æ—Å–∫–æ—Å—Ç—å (–¥–ª—è –¥–≤—É–º–µ—Ä–Ω–æ–≥–æ —Å–ª—É—á–∞—è - –ø—Ä—è–º–∞—è), —Ç–∞–∫–∞—è,<br>—á—Ç–æ –æ–¥–Ω–∞ –≥–µ–æ–º–µ—Ç—Ä–∏—è –ª–µ–∂–∏—Ç –ø–æ –æ–¥–Ω—É –µ—ë —Å—Ç–æ—Ä–æ–Ω—É, –∞ –¥—Ä—É–≥–∞—è<br>- –ø–æ –¥—Ä—É–≥—É—é')" onmouseout="hide()">SAT</a>, –∫–æ—Ç–æ—Ä—ã–µ –º—ã –æ–±—Å—É–∂–¥–∞–ª–∏ —É–∂–µ –∑–¥–µ—Å—å –≤ –ø—Ä–µ–¥—ã–¥—É—â–∏—Ö —Ä—É–∫–æ–≤–æ–¥—Å—Ç–≤–∞—Ö.
<!-- http://www.dyn4j.org/2010/01/sat/ --></div><br>

<h4>–ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ –≤—ã–ø—É–∫–ª—ã—Ö –æ–±–æ–ª–æ—á–µ–∫ –≤ –∏–≥—Ä–µ</h4>
<div class="caption"><img src="img/4.png" width=600></div><br>
–ü—Ä–µ–∂–¥–µ —á–µ–º –Ω–∞—á–∞—Ç—å, —Ö–æ—á–µ—Ç—Å—è –ø–æ–∫–∞–∑–∞—Ç—å –¥–≤–∞ –≤–∏–¥–µ–æ—Ä–æ–ª–∏–∫–∞, —á—Ç–æ–±—ã –±—ã–ª–æ –ø—Ä–µ–¥—Å—Ç–∞–≤–ª–µ–Ω–∏–µ –æ —Ç–æ–º, –∫–∞–∫ –≤—ã–ø—É–∫–ª—ã–µ –æ–±–æ–ª–æ—á–∫–∏ –∏—Å–ø–æ–ª—å–∑—É—é—Ç—Å—è –≤ –∏–≥—Ä–∞—Ö:
<div class=blockindent>&nbsp; &#9679; &nbsp; –ü–æ–∫–∞–∑–∞—Ç—å –≤–∏–¥–µ–æ—Ä–æ–ª–∏–∫ –æ –≤—ã–ø—É–∫–ª—ã—Ö –æ–±–æ–ª–æ—á–∫–∞—Ö –≤ –∏–≥—Ä–µ.</div>
<div class=blockindent>&nbsp; &#9679; &nbsp; –ü–æ–∫–∞–∑–∞—Ç—å, –∫–∞–∫ —Ñ–∏–∑–∏—á–µ—Å–∫–∏–π –¥–≤–∏–∂–æ–∫ —Ä–∞—Å—Å–º–∞—Ç—Ä–∏–≤–∞–µ—Ç –∏–≥—Ä—É.</div>

Sergiy will show you how to implement awesome physics visualization right after this talk!<br><br>
–ù–∞–¥–µ—é—Å—å —á—Ç–æ –≤–∏–¥–µ–æ—Ä–æ–ª–∏–∫–∏ –¥–∞–ª–∏ –æ–±—â–µ–µ –ø—Ä–µ–¥—Å—Ç–∞–≤–ª–µ–Ω–∏–µ –ø—Ä–æ–±–ª–µ–º—ã, –∫–æ—Ç–æ—Ä—É—é –º—ã –ø–æ–ø—ã—Ç–∞–µ–º—Å—è –∑–¥–µ—Å—å —Ä–µ—à–∏—Ç—å.<br><br>


–ö–æ–≥–¥–∞ —è –Ω–∞—á–∞–ª –ø—Ä–∏—Å–º–∞—Ç—Ä–∏–≤–∞—Ç—å—Å—è –∫ –ø–æ—Å—Ç—Ä–æ–µ–Ω–∏—é –≤—ã–ø—É–∫–ª—ã—Ö –æ–±–æ–ª–æ—á–µ–∫, —Ç–æ –±—ã—Å—Ç—Ä–æ –Ω–∞—Ç–∫–Ω—É–ª—Å—è –Ω–∞ –∞–ª–≥–æ—Ä–∏—Ç–º –ø–æ–¥ –Ω–∞–∑–≤–∞–Ω–∏–µ–º Quickhull:
<div class=blockindent>&nbsp; &#9679; &nbsp; Quickhull –±—ã–ª –≤—ã–ø—É—â–µ–Ω –≤ 1995 –≥–æ–¥—É Barber –∏ Dobkin.</div>
<div class=blockindent>&nbsp; &#9679; &nbsp; –ü–æ —Å—É—â–µ—Å—Ç–≤—É —ç—Ç–æ –ø–æ—à–∞–≥–æ–≤—ã–π (–∏—Ç–µ—Ä–∞—Ç–∏–≤–Ω—ã–π) –∞–ª–≥–æ—Ä–∏—Ç–º, –∫–æ—Ç–æ—Ä—ã–π –¥–æ–±–∞–≤–ª—è–µ—Ç –æ—Ç–¥–µ–ª—å–Ω—ã–µ —Ç–æ—á–∫–∏ (–ø–æ –æ–¥–Ω–æ–π –∑–∞ —Ä–∞–∑) –∫ –ø—Ä–æ–º–µ–∂—É—Ç–æ—á–Ω–æ–π –æ–±–æ–ª–æ—á–∫–µ.</div>
<div class=blockindent>&nbsp; &#9679; &nbsp; –ü—Ä–∏ —Ä–µ–∞–ª–∏–∑–∞—Ü–∏–∏ –∞–ª–≥–æ—Ä–∏—Ç–º–∞ –¥–ª—è –ø–æ—Å—Ç—Ä–æ–µ–Ω–∏—è –≤—ã–ø—É–∫–ª—ã—Ö –æ–±–æ–ª–æ—á–µ–∫ –ø—Ä–∏—Ö–æ–¥–∏—Ç—Å—è –∏–º–µ—Ç—å –¥–µ–ª–æ —Å –≤—Ö–æ–¥–Ω–æ–π –≥–µ–æ–º–µ—Ç—Ä–∏–µ–π, –∫–æ—Ç–æ—Ä–∞—è —Å—Ç–∞–ª–∫–∏–≤–∞–µ—Ç—Å—è —Å –æ–≥—Ä–∞–Ω–∏—á–µ–Ω–∏–µ–º —Ç–æ—á–Ω–æ—Å—Ç–∏ –≤—ã—á–∏—Å–ª–µ–Ω–∏–π —Å –ø–ª–∞–≤–∞—é—â–µ–π –∑–∞–ø—è—Ç–æ–π.</div>
<div class=blockindent>&nbsp; &#9679; &nbsp; –î–ª—è —Ä–µ—à–µ–Ω–∏—è —ç—Ç–∏—Ö –ø—Ä–æ–±–ª–µ–º Quickhull –∏—Å–ø–æ–ª—å–∑—É–µ—Ç —Ç–∞–∫ –Ω–∞–∑—ã–≤–∞–µ–º—ã–µ "—Ç–æ–ª—Å—Ç—ã–µ" –ø–ª–æ—Å–∫–æ—Å—Ç–∏ –∏ –æ–±—ä–µ–¥–∏–Ω–µ–Ω–∏–µ –≥—Ä–∞–Ω–µ–π.</div>
<div class=blockindent>&nbsp; &#9679; &nbsp; –í —Ä–µ–∑—É–ª—å—Ç–∞—Ç–µ —Ä–∞–±–æ—Ç—ã –∞–ª–≥–æ—Ä–∏—Ç–º–∞ –ø–æ—è–≤–ª—è–µ—Ç—Å—è –Ω–∞–±–æ—Ä "—Ç–æ–ª—Å—Ç—ã—Ö" –≥—Ä–∞–Ω–µ–π, –∫–æ—Ç–æ—Ä—ã–µ –æ–≥—Ä–∞–Ω–∏—á–∏–≤–∞—é—Ç –∫–æ–Ω–∫—Ä–µ—Ç–Ω—É—é –≤—ã–ø—É–∫–ª—É—é –æ–±–æ–ª–æ—á–∫—É.</div>
–í –ø–æ—Å–ª–µ–¥—É—é—â–µ–π —á–∞—Å—Ç–∏ –ª–µ–∫—Ü–∏–∏ –ø–æ–ø—Ä–æ–±—É–µ–º –ø–æ–¥—Ä–æ–±–Ω–æ —Ä–∞–∑—ä—è—Å–Ω–∏—Ç—å, —á—Ç–æ —ç—Ç–æ –∑–Ω–∞—á–∏—Ç!<br><br>

<!-- Page 9 -->
–ó–Ω–∞–∫–æ–º—Å—Ç–≤–æ —Å –∞–ª–≥–æ—Ä–∏—Ç–º–æ–º –Ω–∞—á–Ω–µ–º —Å –µ–≥–æ –≤–∞—Ä–∏–∞–Ω—Ç–∞ –≤ 2D –ø—Ä–æ—Å—Ç—Ä–∞–Ω—Å—Ç–≤–µ.
<div class=blockindent>&nbsp; &#9679; &nbsp; –•–æ—Ç–µ–ª–æ—Å—å –±—ã –æ—Ç–º–µ—Ç–∏—Ç—å, —á—Ç–æ —ç—Ç–æ –Ω–µ "—Ä–µ–∞–ª—å–Ω—ã–π" –∞–ª–≥–æ—Ä–∏—Ç–º Quickhull –¥–ª—è 2D –ø—Ä–æ—Å—Ç—Ä–∞–Ω—Å—Ç–≤–∞ (–∫–æ—Ç–æ—Ä—ã–π —Å—É—â–µ—Å—Ç–≤—É–µ—Ç –Ω–∞ —Å–∞–º–æ–º –¥–µ–ª–µ).
–°–ª–µ–¥—É–µ—Ç –¥—É–º–∞—Ç—å –æ –Ω–µ–º –∫–∞–∫ –æ –≤–≤–æ–¥–Ω–æ–π —á–∞—Å—Ç–∏ –≤ —Ç—Ä–µ—Ö–º–µ—Ä–Ω—É—é –≤–µ—Ä—Å–∏—é, –∫–æ—Ç–æ—Ä–∞—è –ø–æ–∑–∂–µ –±—É–¥–µ—Ç —Ä–∞—Å—Å–º–æ—Ç—Ä–µ–Ω–∞ –≤ —ç—Ç–æ–π —Å—Ç–∞—Ç—å–µ.</div>
<div class=blockindent>&nbsp; &#9679; &nbsp; –õ–∏—á–Ω–æ —è —Å—á–∏—Ç–∞—é, —á—Ç–æ –∑–∞—á–∞—Å—Ç—É—é –ø–æ–ª–µ–∑–Ω–æ —Å–Ω–∞—á–∞–ª–∞ —Ä–∞—Å—Å–º–æ—Ç—Ä–µ—Ç—å –≤—Å–µ —ç—Ç–∏ –≤–µ—â–∏ –≤ 2D, —á—Ç–æ–±—ã –æ–∑–Ω–∞–∫–æ–º–∏—Ç—å—Å—è —Å –æ—Å–Ω–æ–≤–Ω—ã–º–∏ –∏–¥–µ—è–º–∏ –∏ —Ö–æ—Ä–æ—à–æ –ø–æ–Ω—è—Ç—å –∑–∞–¥–∞—á—É.</div>

<!-- Page 10 -->
<h3>Quickhull 2D: –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –æ–±–æ–ª–æ—á–∫–∏</h3>
–ü—Ä–µ–¥–ø–æ–ª–æ–∂–∏–º, —á—Ç–æ –∑–∞–¥–∞–Ω –Ω–∞–±–æ—Ä —Ç–æ—á–µ–∫, –∏ –Ω—É–∂–Ω–æ –ø–æ—Å—Ç—Ä–æ–∏—Ç—å –≤—ã–ø—É–∫–ª—É—é –æ–±–æ–ª–æ—á–∫—É —Å –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ–º –∞–ª–≥–æ—Ä–∏—Ç–º–∞ Quickhull:
<div class=blockindent>&nbsp; &#9679; &nbsp; –ü–µ—Ä–≤–æ–µ, —á—Ç–æ –Ω—É–∂–Ω–æ —Å–¥–µ–ª–∞—Ç—å –≤ Quickhull, - —ç—Ç–æ –ø–æ—Å—Ç—Ä–æ–∏—Ç—å –∏—Å—Ö–æ–¥–Ω—É—é –æ–±–æ–ª–æ—á–∫—É, –∏–∑ –∫–æ—Ç–æ—Ä–æ–π –º–æ–∂–Ω–æ –Ω–∞—á–∞—Ç—å –ø–æ—à–∞–≥–æ–≤–æ –¥–æ–±–∞–≤–ª—è—Ç—å —Ç–æ—á–∫–∏.</div>
<div class="caption"><img src="img/5.png" width=500></div>
–ü–æ–∏—Å–∫ —ç—Ç–æ–π –∏—Å—Ö–æ–¥–Ω–æ–π –æ–±–æ–ª–æ—á–∫–∏ –Ω–∞—á–Ω–µ–º —Å –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏—è –∫—Ä–∞–π–Ω–∏—Ö —Ç–æ—á–µ–∫ –ø–æ –∫–∞–∂–¥–æ–π –∏–∑ –æ—Å–µ–π –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç.
<div class=blockindent>&nbsp; &#9679; &nbsp; –ï—Å–ª–∏ –ø–æ –ø—Ä–æ—Å—Ç–æ–º—É, —Ç–æ —ç—Ç–æ –æ–∑–Ω–∞—á–∞–µ—Ç, —á—Ç–æ –Ω—É–∂–Ω–æ –Ω–∞–π—Ç–∏ —Ç–æ—á–∫–∏ —Å –Ω–∞–∏–±–æ–ª—å—à–∏–º–∏ –∏ –Ω–∞–∏–º–µ–Ω—å—à–∏–º–∏ –∑–Ω–∞—á–µ–Ω–∏—è–º–∏ –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç&nbsp;<tt>x</tt>&nbsp;–∏&nbsp;<tt>y</tt>.</div>
<div class="caption"><img src="img/6.png" width=700></div>
–ò–∑ —ç—Ç–∏—Ö —á–µ—Ç—ã—Ä–µ—Ö —Ç–æ—á–µ–∫ –≤—ã–±–∏—Ä–∞–µ–º –ø–∞—Ä—É, –≤ –∫–æ—Ç–æ—Ä–æ–π —Ç–æ—á–∫–∏ –Ω–∞—Ö–æ–¥—è—Ç—Å—è –Ω–∞ —Å–∞–º–æ–º –±–æ–ª—å—à–æ–º —Ä–∞—Å—Å—Ç–æ—è–Ω–∏–∏ –¥—Ä—É–≥ –æ—Ç –¥—Ä—É–≥–∞.
<div class=blockindent>&nbsp; &#9679; &nbsp; –í –¥–∞–Ω–Ω–æ–º –ø—Ä–∏–º–µ—Ä–µ —ç—Ç–æ –±—É–¥—É—Ç —Å–∞–º–∞—è –ª–µ–≤–∞—è –∏ —Å–∞–º–∞—è –ø—Ä–∞–≤–∞—è —Ç–æ—á–∫–∏.</div>
<div class="caption"><img src="img/7.png" width=500></div>
–ù–∞–∫–æ–Ω–µ—Ü, –º—ã –∏—â–µ–º —Å–∞–º—É—é –¥–∞–ª—å–Ω—é—é —Ç–æ—á–∫—É –æ—Ç –ª–∏–Ω–∏–∏, –ø—Ä–æ–≤–µ–¥–µ–Ω–Ω–æ–π —á–µ—Ä–µ–∑ —ç—Ç–∏ –¥–≤–µ –∫—Ä–∞–π–Ω–∏–µ —Ç–æ—á–∫–∏
<div class="caption"><img src="img/8.png" width=500></div>
–≠—Ç–∏ —Ç—Ä–∏ —Ç–æ—á–∫–∏ –∏ –¥–∞–¥—É—Ç –Ω–∞—à—É –ø–µ—Ä–≤–æ–Ω–∞—á–∞–ª—å–Ω—É—é –æ–±–æ–ª–æ—á–∫—É.
<div class=blockindent>&nbsp; &#9679; &nbsp; –ü–µ—Ä–≤–æ–Ω–∞—á–∞–ª—å–Ω–∞—è –æ–±–æ–ª–æ—á–∫–∞ –≤ –¥–≤—É–º–µ—Ä–Ω–æ–º –ø—Ä–æ—Å—Ç—Ä–∞–Ω—Å—Ç–≤–µ - —ç—Ç–æ –ø—Ä–æ—Å—Ç–æ —Ç—Ä–µ—É–≥–æ–ª—å–Ω–∏–∫.</div>
<div class="caption"><img src="img/9.png" width=500></div><br>

<h3>Quickhull 2D: –†–∞–∑–¥–µ–ª–µ–Ω–∏–µ —Ç–æ—á–µ–∫</h3>
–ü—Ä–µ–∂–¥–µ —á–µ–º –Ω–∞—á–∞—Ç—å –¥–æ–±–∞–≤–ª—è—Ç—å –Ω–æ–≤—ã–µ —Ç–æ—á–∫–∏ –∫ –∏—Å—Ö–æ–¥–Ω–æ–π –æ–±–æ–ª–æ—á–∫–µ, –Ω—É–∂–Ω–æ —Å–¥–µ–ª–∞—Ç—å –Ω–µ–∫–æ—Ç–æ—Ä—ã–µ –±—É—Ö–≥–∞–ª—Ç–µ—Ä—Å–∫–∏–µ —Ä–∞–±–æ—Ç—ã:
Before we start adding new points to the initial hull we have to do some book-keeping work:

<div class=blockindent>&nbsp; &#9679; &nbsp; –°–ª–µ–¥—É—é—â–∏–º —à–∞–≥–æ–º –±—É–¥–µ—Ç —Ä–∞–∑–¥–µ–ª–µ–Ω–∏–µ –æ—Å—Ç–∞–≤—à–∏—Ö—Å—è —Ç–æ—á–µ–∫ –∏ –ø—Ä–∏—Å–≤–æ–µ–Ω–∏–µ –∫–∞–∂–¥–æ–π —Ç–æ—á–∫–∏ –±–ª–∏–∂–∞–π—à–µ–π –∫ –Ω–µ–π –≥—Ä–∞–Ω–∏.
The next step is to partition the remaining points and assign each point to its closest face</div>

<div class=blockindent>&nbsp; &#9679; &nbsp; –¢–∞–∫–∂–µ –º–æ–∂–Ω–æ —É–¥–∞–ª–∏—Ç—å —Ç–æ—á–∫–∏ –≤–Ω—É—Ç—Ä–∏ –∏—Å—Ö–æ–¥–Ω–æ–π –æ–±–æ–ª–æ—á–∫–∏, –ø–æ—Å–∫–æ–ª—å–∫—É –æ–Ω–∏ –Ω–µ –º–æ–≥—É—Ç –±—ã—Ç—å –Ω–∞ —Ñ–∏–Ω–∞–ª—å–Ω–æ–º –≤–∞—Ä–∏–∞–Ω—Ç–µ –æ–±–æ–ª–æ—á–∫–∏.</div>
<div class="caption"><img src="img/10.png" width=800><br>
–ü–æ—è—Å–Ω–µ–Ω–∏–µ –∫ –∫–æ–¥—É –Ω–∞ –∫–∞—Ä—Ç–∏–Ω–∫–µ: <tt>CL</tt> - —Å–æ–∫—Ä–∞—â. –∞–Ω–≥–ª. —Å–ª–æ–≤ conflict list - —Å–ø–∏—Å–æ–∫ –∫–æ–Ω—Ñ–ª–∏–∫—Ç–æ–≤, –∞ <tt>CL(e1)={p1, p2, p3}</tt> –æ–∑–Ω–∞—á–∞–µ—Ç, —á—Ç–æ —Å–ø–∏—Å–æ–∫ –∫–æ–Ω—Ñ–ª–∏–∫—Ç–æ–≤ –≥—Ä–∞–Ω–∏ <tt>e1</tt> —Å–æ–¥–µ—Ä–∂–∏—Ç —Ç–æ—á–∫–∏ <tt>p1</tt>, <tt>p2</tt> –∏ <tt>p3</tt>.</div><br>

–≠—Ç–æ –æ–∑–Ω–∞—á–∞–µ—Ç, —á—Ç–æ –∫–∞–∂–¥–∞—è –≥—Ä–∞–Ω—å –≤–µ–¥–µ—Ç —Å–ø–∏—Å–æ–∫ —Ç–æ—á–µ–∫, –∫–æ—Ç–æ—Ä—ã–µ –Ω–∞—Ö–æ–¥—è—Ç—Å—è –≤–Ω–µ –ø–ª–æ—Å–∫–æ—Å—Ç–∏ –≥—Ä–∞–Ω–∏. –≠—Ç–∏ —Å–ø–∏—Å–∫–∏ –Ω–∞–∑—ã–≤–∞—é—Ç—Å—è ¬´—Å–ø–∏—Å–∫–∞–º–∏ –∫–æ–Ω—Ñ–ª–∏–∫—Ç–æ–≤¬ª, –ø–æ—Å–∫–æ–ª—å–∫—É —Ç–æ—á–∫–∏ –º–æ–≥—É—Ç ¬´–≤–∏–¥–µ—Ç—å¬ª —ç—Ç—É –≥—Ä–∞–Ω—å –∏ —Å–ª–µ–¥–æ–≤–∞—Ç–µ–ª—å–Ω–æ, –≤–æ–∑–º–æ–∂–Ω–æ –Ω–∞—Ö–æ–¥—è—Ç—Å—è –Ω–∞ —Ñ–∏–Ω–∞–ª—å–Ω–æ–º –≤–∞—Ä–∏–∞–Ω—Ç–µ –æ–±–æ–ª–æ—á–∫–∏.
–≠—Ç–æ –≥—Ä–∞–º–æ—Ç–Ω—ã–π —Å–ø–æ—Å–æ–± —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è –≤–µ—Ä—à–∏–Ω–∞–º–∏, –ø–æ—Å–∫–æ–ª—å–∫—É –ø—Ä–∏ –¥–æ–±–∞–≤–ª–µ–Ω–∏–∏ –∫ –æ–±–æ–ª–æ—á–∫–µ –Ω–æ–≤–æ–π –≤–µ—Ä—à–∏–Ω—ã –Ω–µ –Ω—É–∂–Ω–æ –ø–µ—Ä–µ–±–∏—Ä–∞—Ç—å –≤—Å–µ –≤–µ—Ä—à–∏–Ω—ã.
–ü–æ—ç—Ç–æ–º—É <a href="https://ru.wikipedia.org/wiki/%D0%92%D1%80%D0%B5%D0%BC%D0%B5%D0%BD%D0%BD%D0%B0%D1%8F_%D1%81%D0%BB%D0%BE%D0%B6%D0%BD%D0%BE%D1%81%D1%82%D1%8C_%D0%B0%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D0%B0" target="_blank">–≤—Ä–µ–º–µ–Ω–Ω–∞&#769;—è —Å–ª–æ–∂–Ω–æ—Å—Ç—å –∞–ª–≥–æ—Ä–∏—Ç–º–∞</a>
Quickhull –æ–±—ã—á–Ω–æ —Ä–∞–≤–Ω–∞ <span class="lnk" onmouseover="show('–ª–∏–Ω–µ–π–Ω–æ-–ª–æ–≥–∞—Ä–∏—Ñ–º–∏—á–µ—Å–∫–æ–µ –≤—Ä–µ–º—è,<br>–º–∞–∫—Å–∏–º–∞–ª—å–Ω–æ –±—ã—Å—Ç—Ä–∞—è —Å–æ—Ä—Ç–∏—Ä–æ–≤–∫–∞<br>—Å—Ä–∞–≤–Ω–µ–Ω–∏–µ–º')" onmouseout="hide()"><tt>O(n log n)</tt></span> –∫–∞–∫ –≤ –¥–≤—É–º–µ—Ä–Ω–æ–º, —Ç–∞–∫ –∏ –≤ —Ç—Ä–µ—Ö–º–µ—Ä–Ω–æ–º –≤–∞—Ä–∏–∞–Ω—Ç–∞—Ö!
<div class=warning><b>–ü—Ä–µ–¥—É–ø—Ä–µ–∂–¥–µ–Ω–∏–µ:</b> –ü–æ–∂–∞–ª—É–π—Å—Ç–∞ –Ω–µ –∑–∞–ø—É—Ç–∞–π—Ç–µ—Å—å –∑–¥–µ—Å—å. –¢–∞–∫ –∫–∞–∫ –∞–ª–≥–æ—Ä–∏—Ç–º –ø—Ä–µ–¥—Å—Ç–∞–≤–ª–µ–Ω –≤ –¥–≤—É—Ö- –∏ —Ç—Ä–µ—Ö–º–µ—Ä–Ω–æ–º –≤–∞—Ä–∏–∞–Ω—Ç–∞—Ö –∏ –Ω–µ–∫–æ—Ç–æ—Ä–∞—è —Ç–µ—Ä–º–∏–Ω–æ–ª–æ–≥–∏—è —Å–æ–≤–ø–∞–¥–∞–µ—Ç, –±—É–¥–µ–º –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å —Ç–µ—Ä–º–∏–Ω—ã ¬´Edge¬ª (—Ä–µ–±—Ä–æ, –∫—Ä–∞–π) –∏ ¬´Face¬ª (–≥—Ä–∞–Ω—å) –≤–∑–∞–∏–º–æ–∑–∞–º–µ–Ω—è–µ–º—ã–µ! –≠—Ç–æ –ø–æ–º–æ–∂–µ—Ç, –∫–æ–≥–¥–∞ –ø–æ–∑–∂–µ –≤ —ç—Ç–æ–π –ª–µ–∫—Ü–∏–∏ –ø–µ—Ä–µ–π–¥–µ–º –∫ —Ç—Ä–µ—Ö–º–µ—Ä–Ω–æ–º—É –≤–∞—Ä–∏–∞–Ω—Ç—É –∞–ª–≥–æ—Ä–∏—Ç–º–∞!

Please don‚Äôt get confused here. Since I am presenting in 2D and 3D and some terminology overlaps I will use the terms ‚ÄòEdge‚Äô and ‚ÄòFace‚Äô interchangeable! This will usually help when we go to 3D later in the talk!</div><br>


<h3>Quickhull 2D: –ü–æ–∏—Å–∫ —Å–ª–µ–¥—É—é—â–µ–π –≤–µ—Ä—à–∏–Ω—ã</h3>
–°–ª–µ–¥—É—é—â–∏–º —à–∞–≥–æ–º –±—É–¥–µ—Ç –¥–æ–±–∞–≤–ª–µ–Ω–∏–µ –Ω–æ–≤–æ–π —Ç–æ—á–∫–∏ –∫ –Ω–∞—à–µ–º—É –ø—Ä–æ–º–µ–∂—É—Ç–æ—á–Ω–æ–º—É –≤–∞—Ä–∏–∞–Ω—Ç—É –æ–±–æ–ª–æ—á–∫–∏. –ü–µ—Ä–µ–±–∏—Ä–∞–µ–º –Ω–∞—à–∏ —Å–ø–∏—Å–∫–∏ –∫–æ–Ω—Ñ–ª–∏–∫—Ç–æ–≤ –∏ –Ω–∞—Ö–æ–¥–∏–º —Ç–æ—á–∫—É <b>p</b> —Å –Ω–∞–∏–±–æ–ª—å—à–∏–º —Ä–∞—Å—Å—Ç–æ—è–Ω–∏–µ–º –æ—Ç —ç—Ç–æ–π –æ–±–æ–ª–æ—á–∫–∏.
<div class=blockindent>&nbsp; &#9679; &nbsp; –î–∞–≤–∞–π—Ç–µ –Ω–∞–∑–æ–≤–µ–º —ç—Ç—É —Ç–æ—á–∫—É —Ç–æ—á–∫–æ–π –ø—Ä–æ—Å–º–æ—Ç—Ä–∞ –∏–ª–∏ –æ–±–∑–æ—Ä–∞.</div>
<div class=blockindent>&nbsp; &#9679; &nbsp; –î–æ–±–∞–≤–ª–µ–Ω–∏–µ —ç—Ç–æ–π –Ω–æ–≤–æ–π —Ç–æ—á–∫–∏ –ø–æ—Ç—Ä–µ–±—É–µ—Ç –Ω–µ—Å–∫–æ–ª—å–∫–æ –¥–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã—Ö —à–∞–≥–æ–≤.</div>
<div class="caption"><img src="img/11.png" width=500></div><br>

<h3>Quickhull 2D: –ü–æ–∏—Å–∫ –≥–æ—Ä–∏–∑–æ–Ω—Ç–∞</h3>
<div class="caption"><img src="img/12.png" width=700></div>
–°–Ω–∞—á–∞–ª–∞ –Ω–∞–º –Ω—É–∂–Ω–æ –æ–ø—Ä–µ–¥–µ–ª–∏—Ç—å –≤—Å–µ –≥—Ä–∞–Ω–∏, –∫–æ—Ç–æ—Ä—ã–µ –≤–∏–¥–Ω—ã –∏–∑ –Ω–µ–¥–∞–≤–Ω–æ –¥–æ–±–∞–≤–ª–µ–Ω–Ω–æ–π —Ç–æ—á–∫–∏, –ø–æ—Å–∫–æ–ª—å–∫—É —ç—Ç–∏ –≥—Ä–∞–Ω–∏ –º–æ–≥—É—Ç –±—ã—Ç—å –Ω–µ –Ω–∞ –æ–±–æ–ª–æ—á–∫–µ:
First we need to identify all faces that are visible from the newly added point since these faces cannot be on the hull:

<div class=blockindent>&nbsp; &#9679; &nbsp; –ì—Ä–∞–Ω—å —è–≤–ª—è–µ—Ç—Å—è –≤–∏–¥–∏–º–æ–π, –µ—Å–ª–∏ —ç—Ç–∞ –Ω–æ–≤–∞—è —Ç–æ—á–∫–∞ –Ω–∞—Ö–æ–¥–∏—Ç—Å—è –ø–µ—Ä–µ–¥ –ø–ª–æ—Å–∫–æ—Å—Ç—å—é –≥—Ä–∞–Ω–∏. A face is visible if the new point is in front of the face plane.</div>

<div class=blockindent>&nbsp; &#9679; &nbsp; –ú–æ–∂–Ω–æ –≤–æ—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å—Å—è –ø—Ä–æ—Å—Ç—ã–º–∏ –ø—Ä–æ–≤–µ—Ä–∫–∞–º–∏ –ø–ª–æ—Å–∫–æ—Å—Ç–∏ —á—Ç–æ–±—ã –ø—Ä–∏—á–∏—Å–ª–∏—Ç—å —ç—Ç—É –Ω–æ–≤—É—é —Ç–æ—á–∫—É –ø–æ –æ—Ç–Ω–æ—à–µ–Ω–∏—é –∫ –∫–∞–∂–¥–æ–π –≥—Ä–∞–Ω–∏!
We can use simple plane tests to classify the new point against each face!</div>

<div class=blockindent>&nbsp; &#9679; &nbsp; –°–ª–µ–¥—É—é—â–∏–π —à–∞–≥ —Å–æ—Å—Ç–æ–∏—Ç –≤ —Ç–æ–º, —á—Ç–æ–±—ã –Ω–∞–π—Ç–∏ –¥–≤–µ –≤–µ—Ä—à–∏–Ω—ã, —Å–æ–µ–¥–∏–Ω—è—é—â–∏–µ –≤–∏–¥–∏–º—É—é –≥—Ä–∞–Ω—å —Å –Ω–µ–≤–∏–¥–∏–º–æ–π.</div>
<div class=blockindent>&nbsp; &#9679; &nbsp; –≠—Ç–∏ –¥–≤–µ –≤–µ—Ä—à–∏–Ω—ã (<tt>H1</tt> –∏ <tt>H2</tt>) –Ω–∞–∑—ã–≤–∞—é—Ç—Å—è –≥–æ—Ä–∏–∑–æ–Ω—Ç–æ–º.</div>
<div class=blockindent>&nbsp; &#9679; &nbsp; –§–∞–∫—Ç–∏—á–µ—Å–∫–∏, –≥–æ—Ä–∏–∑–æ–Ω—Ç —è–≤–ª—è–µ—Ç—Å—è –≥—Ä–∞–Ω–∏—Ü–µ–π –º–µ–∂–¥—É –≤–∏–¥–∏–º–æ–π –∏ –Ω–µ–≤–∏–¥–∏–º–æ–π —á–∞—Å—Ç—è–º–∏ —Ç–µ–∫—É—â–µ–π –æ–±–æ–ª–æ—á–∫–∏, –∫–∞–∫ –æ–Ω–æ –≤–∏–¥–∏—Ç—Å—è –∏–∑ –Ω–æ–≤–æ–π —Ç–æ—á–∫–∏ –ø—Ä–æ—Å–º–æ—Ç—Ä–∞.</div><br>

<h3>Quickhull 2D: –î–æ–±–∞–≤–ª–µ–Ω–∏–µ —Ç–æ—á–∫–∏ –∫ –æ–±–æ–ª–æ—á–∫–µ</h3>
–ü–æ—Å–ª–µ –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏—è –¥–≤—É—Ö –≤–µ—Ä—à–∏–Ω –≥–æ—Ä–∏–∑–æ–Ω—Ç–∞, —Å–æ–∑–¥–∞–¥–∏–º –¥–≤–µ –Ω–æ–≤—ã–µ –≥—Ä–∞–Ω–∏ –æ—Ç –∫–∞–∂–¥–æ–π –≤–µ—Ä—à–∏–Ω—ã –≥–æ—Ä–∏–∑–æ–Ω—Ç–∞ –¥–ª—è –ø—Ä–∏—Å–æ–µ–¥–∏–Ω–µ–Ω–∏—è –Ω–æ–≤–æ–π –≤–µ—Ä—à–∏–Ω—ã –∫ –æ–±–æ–ª–æ—á–∫–µ.
Once we identified the two horizon vertices we then create two new faces for each horizon vertex to connect the new vertex to hull
<div class="caption"><img src="img/13.png" width=500></div><br>

<!-- Page 19 -->
<h3>Quickhull 2D: Partition orphans</h3>
<div class="caption"><img src="img/14.png" width=800><br></div>
–ü–æ—Å–ª–µ –ø–æ—Å—Ç—Ä–æ–µ–Ω–∏—è –Ω–æ–≤—ã—Ö –≥—Ä–∞–Ω–µ–π –Ω–µ–∫–æ—Ç–æ—Ä—ã–µ —Å—Ç–∞—Ä—ã–µ –≥—Ä–∞–Ω–∏ —Å—Ç–∞–ª–∏ —É—Å—Ç–∞—Ä–µ–≤—à–∏–º–∏.
After building  the new faces some old faces became obsolete

<div class=blockindent>&nbsp; &#9679; &nbsp; –ü—Ä–µ–∂–¥–µ —á–µ–º —É–¥–∞–ª–∏—Ç—å —ç—Ç–∏ –≥—Ä–∞–Ω–∏, –Ω—É–∂–Ω–æ –æ–±—Ä–∞–±–æ—Ç–∞—Ç—å –∏—Ö —Å–ø–∏—Å–∫–∏ –∫–æ–Ω—Ñ–ª–∏–∫—Ç–æ–≤, –ø–æ—Å–∫–æ–ª—å–∫—É —ç—Ç–∏ –∫–æ–Ω—Ñ–ª–∏–∫—Ç–Ω—ã–µ —Ç–æ—á–∫–∏ –º–æ–≥—É—Ç –æ—Å—Ç–∞—Ç—å—Å—è –Ω–∞ —Ñ–∏–Ω–∞–ª—å–Ω–æ–º –≤–∞—Ä–∏–∞–Ω—Ç–µ –æ–±–æ–ª–æ—á–∫–∏.
Before we can delete these faces we need to handle their conflict lists since these conflict points can still be on the final hull</div>

<div class=blockindent>&nbsp; &#9679; &nbsp; We handle this by simply partitioning these orphaned vertices to the new faces</div>


<!-- Page 20 -->
<h3>Quickhull 2D: –î–æ–±–∞–≤–ª–µ–Ω–∏–µ —Ç–æ—á–∫–∏ –∫ –æ–±–æ–ª–æ—á–∫–µ</h3>
<div class="caption"><img src="img/15.png" width=500><br>
</div>
Finally we can now remove all old faces which were visible from the new point and therefore cannot be on the hull anymore

<div class=blockindent>&nbsp; &#9679; &nbsp; This closes the iteration and we repeat those steps until all conflict list are empty</div>

<div class=blockindent>&nbsp; &#9679; &nbsp; In our example we continue and grab the next eye point and add it to hull as we just learned</div>


<!-- Page 21 -->
<div class="caption"><img src="img/16.png" width=500><br>
</div>
And we do it one more time to find our final hull‚Ä¶
–ò –¥–µ–ª–∞–µ–º —ç—Ç–æ –µ—â—ë —Ä–∞–∑, —á—Ç–æ–±—ã –Ω–∞–π—Ç–∏ –Ω–∞—à—É –ø–æ—Å–ª–µ–¥–Ω—é—é –æ–±–æ–ª–æ—á–∫—É...

<!-- Page 22 -->
<h3>Quickhull 2D:</h3>
<div class="caption"><img src="img/17.png" width=500><br>
</div>
When there are no more vertices (which means all conflict lists are empty) we are done!<br><br>

<!-- Page 23 -->
As you can see the basic ideas should be pretty easy to understand

<div class=blockindent>&nbsp; &#9679; &nbsp; In 3D the major implementation difficulties actually arise from managing the lists of vertices, edges, faces and conflicts</div>

<div class=blockindent>&nbsp; &#9679; &nbsp; The other difficulty is dealing with numerical imprecision when classifying  points using plane tests.</div>

<!-- Page 24 -->
So far we pretended that our mathematical operations are exact

<div class=blockindent>&nbsp; &#9679; &nbsp; Of course this is *not* true in floating point arithmetic.</div>

<div class=blockindent>&nbsp; &#9679; &nbsp; Let‚Äôs investigate how we can deal with those problems.</div>

<!-- Page 25 -->
<h3>Quickhull 2D: –ò–Ω–≤–∞—Ä–∏–∞–Ω—Ç—ã Invariants</h3>
<div class="caption"><img src="img/18.png" width=600><br>
</div>
When building a convex hull we must maintain geometric invariants during construction:

<div class=blockindent>&nbsp; &#9679; &nbsp; In 2D we must guarantee that every vertex is convex</div>

<div class=blockindent>&nbsp; &#9679; &nbsp; This should be obvious since otherwise it would be simple to find a line between two points inside the hull that would leave and enter as shown in the slide at the beginning of the talk</div>

<div class=blockindent>&nbsp; &#9679; &nbsp; I tried to hint this with the dotted line between the outside pointing normals on the slide</div>

<!-- Page 26 -->
<h3>Quickhull 2D: –¢–µ—Å—Ç –Ω–∞ –≤—ã–ø—É–∫–ª–æ—Å—Ç—å Convexity test</h3>
<div class="caption"><img src="img/19.png" width=600><br>
</div>
Next we need to define what a convex vertex is and how we can test a vertex for convexity:<br>

–î–ª—è –∫–∞–∂–¥–æ–π –≤–µ—Ä—à–∏–Ω—ã:
<div class=blockindent>&nbsp; &#9679; &nbsp; First test if right vertex is below the left face</div>

<div class=blockindent>&nbsp; &#9679; &nbsp; Then test if left vertex if it is below the right face</div>

<div class=blockindent>&nbsp; &#9679; &nbsp; If both tests are true the vertex is convex, otherwise it must be concave or coplanar</div>


<!-- Page 27 -->
<h3>Quickhull 2D: –ù–∞–¥–µ–∂–Ω–æ—Å—Ç—å –≤—ã—á–∏—Å–ª–µ–Ω–∏–π Numerical robustness</h3>
<div class="caption"><img src="img/20.png" width=600><br>
coplanar - –∫–æ–ø–ª–∞–Ω–∞—Ä–Ω—ã–π, —Ç.–µ. –Ω–∞—Ö–æ–¥—è—â–∏–π—Å—è –≤ –æ–¥–Ω–æ–π –ø–ª–æ—Å–∫–æ—Å—Ç–∏, concave - –≤–æ–≥–Ω—É—Ç—ã–π, convex - –≤—ã–ø—É–∫–ª—ã–π</div>
Let‚Äôs now look at an example where non-convex vertices might become an issue:

<div class=blockindent>&nbsp; &#9679; &nbsp; Whenever we add a point which is collinear with an existing face things can become fuzzy</div>

<div class=blockindent>&nbsp; &#9679; &nbsp; A small variation of point P will define whether the vertex V will remain on the hull or not</div>

<div class=blockindent>&nbsp; &#9679; &nbsp; Ideally we would like to have more stability such that for very small  variations within some tolerance we would get the same result</div>

<div class=blockindent>&nbsp; &#9679; &nbsp; Note that the point P is not actually moving, but can end up on either side of the plane *just* due  to numerical imprecision</div>

<!-- Page 28 -->
<h3>Quickhull 2D: –¢–æ–ª—â–∏–Ω–∞ –ø–ª–æ—Å–∫–æ—Å—Ç–µ–π Fat planes</h3>
<div class="caption"><img src="img/21.png" width=600><br>
in front of plane - –ø–µ—Ä–µ–¥ –ø–ª–æ—Å–∫–æ—Å—Ç—å—é, behind plane - –∑–∞ –ø–ª–æ—Å–∫–æ—Å—Ç—å—é, on plane - –Ω–∞ –ø–ª–æ—Å–∫–æ—Å—Ç–∏</div>
A common approach to deal with these kinds of numerical problems is to use so called *fat* planes

<div class=blockindent>&nbsp; &#9679; &nbsp; Instead of comparing directly against zero we now compare against some epsilon value</div>


We still can classify points when using fat planes as before:

<div class=blockindent>&nbsp; &#9679; &nbsp; A point is in front of the plane if its distance is larger than epsilon</div>

<div class=blockindent>&nbsp; &#9679; &nbsp; A point is behind the plane if the distance is less than negative epsilon</div>

<div class=blockindent>&nbsp; &#9679; &nbsp; Otherwise the point must on the plane.</div>

<b>We can now define a vertex to be convex if its distance is larger than epsilon. All other points are either concave or coplanar and should be handled specially!</b><br><br>

<!-- Page 29 -->
<h3>Quickhull 2D: –û–±—ä–µ–¥–∏–Ω–µ–Ω–∏–µ –≥—Ä–∞–Ω–µ–π Face merging</h3>
<div class="caption"><img src="img/22.png" width=500><br>non-convex - –Ω–µ–≤—ã–ø—É–∫–ª–∞—è, merged - –æ–±—ä–µ–¥–∏–Ω–µ–Ω–Ω—ã–µ</div>
So what do we do when we encounter a non-convex vertex?

<div class=blockindent>&nbsp; &#9679; &nbsp; The rule is essentially that we want every vertex of our hull to be clearly convex</div>

<div class=blockindent>&nbsp; &#9679; &nbsp; We can enforce this rule by simply merging the left and right face across the non-convex vertex into a new face.</div>

<div class=blockindent>&nbsp; &#9679; &nbsp; As you can see on the slide his will remove the concavity and correct the geometrical defect.</div>

<!-- Page 30 -->
<h3>Quickhull 2D: Epsilon</h3>
<div class="caption"><img src="img/23.png" width=500></div>
The final question is what epsilon we should choose for our fat planes:

<div class=blockindent>&nbsp; &#9679; &nbsp; The CRT defines a floating point epsilon but this does NOT take our input set into account.</div>

<div class=blockindent>&nbsp; &#9679; &nbsp; We like to define a relative tolerance which takes the size of the input object into account</div>

<div class=blockindent>&nbsp; &#9679; &nbsp; So one possible solution it to choose an epsilon relative to the sum of maximum absolute coordinates</div>

<div class=blockindent>&nbsp; &#9679; &nbsp; Note that when using FLT_EPSILON without scaling we would fail big time e.g. very small models (where FLT_EPSILON is much bigger than the entire model itself)</div>

<div class=blockindent>&nbsp; &#9679; &nbsp; Or for very large models where the epsilon is too small to make any difference at all</div><br><br>


<!-- Page 31 -->
–ù–∞ —ç—Ç–æ–º –∑–Ω–∞–∫–æ–º—Å—Ç–≤–æ —Å –¥–≤—É–º–µ—Ä–Ω—ã–º –≤–∞—Ä–∏–∞–Ω—Ç–æ–º –∞–ª–≥–æ—Ä–∏—Ç–º–∞ Quickhull –∑–∞–∫–∞–Ω—á–∏–≤–∞–µ—Ç—Å—è:
<div class=blockindent>&nbsp; &#9679; &nbsp; –ù–∞–¥–µ—é—Å—å, —á—Ç–æ —É –≤–∞—Å –ø–æ—è–≤–∏–ª–æ—Å—å –ø–µ—Ä–≤–æ–µ –ø—Ä–µ–¥—Å—Ç–∞–≤–ª–µ–Ω–∏–µ –æ —Ä–∞–±–æ—Ç–µ –∞–ª–≥–æ—Ä–∏—Ç–º–∞.</div>
<div class=blockindent>&nbsp; &#9679; &nbsp; –î–ª—è –¥–≤—É–º–µ—Ä–Ω–æ–≥–æ –ø—Ä–æ—Å—Ç—Ä–∞–Ω—Å—Ç–≤–∞ —É–∂–µ –∏–º–µ—é—Ç—Å—è —Ö–æ—Ä–æ—à–∏–µ –∞–ª–≥–æ—Ä–∏—Ç–º—ã –ø–æ—Å—Ç—Ä–æ–µ–Ω–∏—è –≤—ã–ø—É–∫–ª—ã—Ö –æ–±–æ–ª–æ—á–µ–∫, –∫–æ—Ç–æ—Ä—ã–µ –ª–µ–≥–∫–æ –∏ –ø—Ä–æ—Å—Ç–æ —Ä–µ–∞–ª–∏–∑–æ–≤–∞—Ç—å.</div>
<div class=blockindent>&nbsp; &#9679; &nbsp; –¢–∞–∫ —á—Ç–æ, –µ—Å–ª–∏ –≤–∞—à–∞ –∏–≥—Ä–∞ –¥–≤—É–º–µ—Ä–Ω–∞, —Ä–µ–∫–æ–º–µ–Ω–¥—É—é –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –æ–¥–∏–Ω –∏–∑ –Ω–∏—Ö.</div><br>

–í –æ—Å—Ç–∞–≤—à–µ–π—Å—è —á–∞—Å—Ç–∏ –æ–±—Å—É–∂–¥–µ–Ω–∏—è —Ä–∞—Å—Å–º–æ—Ç—Ä–∏–º, –∫–∞–∫ —Å–æ–∑–¥–∞—é—Ç—Å—è –≤—ã–ø—É–∫–ª—ã–µ –æ–±–æ–ª–æ—á–∫–∏ –≤ 3D –ø—Ä–æ—Å—Ç—Ä–∞–Ω—Å—Ç–≤–µ.
<div class=blockindent>&nbsp; &#9679; &nbsp; –ê–ª–≥–æ—Ä–∏—Ç–º Quickhull –≤ 3D –æ—á–µ–Ω—å –ø–æ—Ö–æ–∂ –Ω–∞ –≤–µ—Ä—Å–∏—é, –∫–æ—Ç–æ—Ä–∞—è —Ç–æ–ª—å–∫–æ —á—Ç–æ –ø–æ–∫–∞–∑–∞–Ω–∞ –≤ –æ–ø–∏—Å–∞–Ω–∏–∏ 2D-–≤–∞—Ä–∏–∞–Ω—Ç–∞.</div>
<div class=blockindent>&nbsp; &#9679; &nbsp; –ù–∞–∏–±–æ–ª–µ–µ –∑–∞–º–µ—Ç–Ω—ã–º –æ—Ç–ª–∏—á–∏–µ–º —è–≤–ª—è–µ—Ç—Å—è –ø–æ—Å—Ç—Ä–æ–µ–Ω–∏–µ –≥–æ—Ä–∏–∑–æ–Ω—Ç–∞ –∏ –º—ã –¥–æ–ª–∂–Ω—ã –∏–º–µ—Ç—å –¥–µ–ª–æ —Å —á–∏—Å–ª–æ–≤–æ–π –Ω–µ—Ç–æ—á–Ω–æ—Å—Ç—å—é –±–æ–ª–µ–µ —Ç—â–∞—Ç–µ–ª—å–Ω–æ
The most notable difference is the construction of the horizon and we  have to deal with numerical imprecision more carefully</div><br><br>

<!-- Page 32 -->
<img src="img/24.png" width=250 align=right>
<h3>Quickhull 3D: –ù–∞—á–∞–ª—å–Ω–∞—è –æ–±–æ–ª–æ—á–∫–∞</h3>
–¢–∞–∫–∂–µ –∫–∞–∫ –∏ –≤ –¥–≤—É–º–µ—Ä–Ω–æ–º –≤–∞—Ä–∏–∞–Ω—Ç–µ, —Å–ø–µ—Ä–≤–∞ –Ω—É–∂–Ω–æ –ø–æ—Å—Ç—Ä–æ–∏—Ç—å –Ω–∞—á–∞–ª—å–Ω—É—é, –∏—Å—Ö–æ–¥–Ω—É—é –æ–±–æ–ª–æ—á–∫—É.
<div class=blockindent>&nbsp; &#9679; &nbsp; –¢–∞–∫–∂–µ –∫–∞–∫ —ç—Ç–æ –¥–µ–ª–∞–ª–æ—Å—å –≤ 2D, –≤–Ω–∞—á–∞–ª–µ –Ω—É–∂–Ω–æ –Ω–∞–π—Ç–∏ –∏—Å—Ö–æ–¥–Ω—ã–π —Ç—Ä–µ—É–≥–æ–ª—å–Ω–∏–∫ <tt>(v1, v2, v3)</tt>.</div>
<div class=blockindent>&nbsp; &#9679; &nbsp; –ó–∞—Ç–µ–º, —Ç–æ—á–Ω–æ —Ç–∞–∫–∂–µ –¥–æ–±–∞–≤–∏–º —Å–∞–º—É—é –¥–∞–ª—å–Ω—é—é —Ç–æ—á–∫—É –æ—Ç —Ç—Ä–µ—É–≥–æ–ª—å–Ω–æ–π –ø–ª–æ—Å–∫–æ—Å—Ç–∏ (–∑–¥–µ—Å—å —ç—Ç–æ <tt>v4</tt>).</div>
<div class=blockindent>&nbsp; &#9679; &nbsp; –í 3D –ø—Ä–æ—Å—Ç—Ä–∞–Ω—Å—Ç–≤–µ –∏—Å—Ö–æ–¥–Ω–∞—è –æ–±–æ–ª–æ—á–∫–∞ —Ç–µ–ø–µ—Ä—å –ø—Ä–µ–¥—Å—Ç–∞–≤–ª—è–µ—Ç —Å–æ–±–æ–π —Ç–µ—Ç—Ä–∞—ç–¥—Ä.</div>
<div class=blockindent>&nbsp; &#9679; &nbsp; –ü–æ—Å–ª–µ –ø–æ—Å—Ç—Ä–æ–µ–Ω–∏—è –∏—Å—Ö–æ–¥–Ω–æ–π –æ–±–æ–ª–æ—á–∫–∏, –¥–∞–ª–µ–µ —Ä–∞–∑–¥–µ–ª–∏–º –æ—Å—Ç–∞–≤—à–∏–µ—Å—è —Ç–æ—á–∫–∏ –≤ —Å–ø–∏—Å–∫–∞—Ö –∫–æ–Ω—Ñ–ª–∏–∫—Ç–æ–≤ –≥—Ä–∞–Ω–µ–π –Ω–∞—à–µ–π –∏—Å—Ö–æ–¥–Ω–æ–π –æ–±–æ–ª–æ—á–∫–∏.</div><br><br>


<!-- Page 33 -->
<h3>Quickhull 3D: –ì–æ—Ä–∏–∑–æ–Ω—Ç</h3>
<div class="caption"><img src="img/25.png" width=600></div>
We then start iteratively adding new points to the hull and grab the point with the largest distance from our conflict lists:

<div class=blockindent>&nbsp; &#9679; &nbsp; This will give us the next eye point</div>

<div class=blockindent>&nbsp; &#9679; &nbsp; As in 2D we need to find the horizon again</div>

<div class=blockindent>&nbsp; &#9679; &nbsp; In 3D the horizon is a list of edges that connect visible with non-visible faces.</div>

<div class=blockindent>&nbsp; &#9679; &nbsp; And again the horizon is the boundary between the visible and non‚Äìvisible part of the current hull as seen from the current eye point</div>

<div class=blockindent>&nbsp; &#9679; &nbsp; Finding the horizon is a bit more involved in 3D and we will look at it in more detail in just a second</div>


<!-- Page 34 -->
<h3>Quickhull 3D: –î–æ–±–∞–≤–ª–µ–Ω–∏–µ —Ç–æ—á–∫–∏ –∫ –æ–±–æ–ª–æ—á–∫–µ</h3>
<div class="caption"><img src="img/26.png" width=600></div>
We then proceed with the iteration and create a new face for each horizon edge with the new eye-point

<div class=blockindent>&nbsp; &#9679; &nbsp; This essentially connects the new vertex to the current hull</div>

<div class=blockindent>&nbsp; &#9679; &nbsp; Finally we partition the orphaned vertices to the new faces (F1 ‚Äì  F3)</div>


<!-- Page 35 -->
<h3>Quickhull 3D: –ü–æ–∏—Å–∫ –≥–æ—Ä–∏–∑–æ–Ω—Ç–∞</h3>
<div class="caption"><img src="img/27.png" width=500></div>
–ù–∞–π—Ç–∏ –≥–æ—Ä–∏–∑–æ–Ω—Ç –≤ —Ç—Ä–µ—Ö–º–µ—Ä–Ω–æ–º –ø—Ä–æ—Å—Ç—Ä–∞–Ω—Å—Ç–≤–µ –Ω–µ —Ç–∞–∫ –ø—Ä–æ—Å—Ç–æ, –∫–∞–∫ —ç—Ç–æ –±—ã–ª–æ –ø—Ä–∏ –ø–æ–∏—Å–∫–µ –¥–≤—É—Ö –≤–µ—Ä—à–∏–Ω –≤ 2D –ø—Ä–æ—Å—Ç—Ä–∞–Ω—Å—Ç–≤–µ.

<div class=blockindent>&nbsp; &#9679; &nbsp; –î–ª—è –Ω–∞—Ö–æ–∂–¥–µ–Ω–∏—è –≥–æ—Ä–∏–∑–æ–Ω—Ç–∞ –ø–æ —Å—É—â–µ—Å—Ç–≤—É –≤—ã–ø–æ–ª–Ω—è–µ—Ç—Å—è <a href="https://ru.wikipedia.org/wiki/%D0%9F%D0%BE%D0%B8%D1%81%D0%BA_%D0%B2_%D0%B3%D0%BB%D1%83%D0%B1%D0%B8%D0%BD%D1%83" onmouseover="show('DFS - —Å–æ–∫—Ä–∞—â. –∞–Ω–≥–ª. —Å–ª–æ–≤ depth-first search - –ø–æ–∏—Å–∫<br>–≤ –≥–ª—É–±–∏–Ω—É, –æ–¥–∏–Ω –∏–∑ –º–µ—Ç–æ–¥–æ–≤ –æ–±—Ö–æ–¥–∞ –≥—Ä–∞—Ñ–∞')" onmouseout="hide()">DFS</a>, –Ω–∞—á–∏–Ω–∞—è —Å
For finding the horizon we essentially perform a DFS starting from the conflict face S</div>

<div class=blockindent>&nbsp; &#9679; &nbsp; –ü—Ä–∏ –∫–∞–∂–¥–æ–º —à–∞–≥–µ –º—ã –ø–µ—Ä–µ—Å–µ–∫–∞–µ–º –æ–¥–Ω–æ —Ä–µ–±—Ä–æ –∏ –ø–µ—Ä–µ—Ö–æ–¥–∏–º –Ω–∞ —Å–æ—Å–µ–¥–Ω—é—é, —Å–º–µ–∂–Ω—É—é –≥—Ä–∞–Ω—å.</div>

<div class=blockindent>&nbsp; &#9679; &nbsp; If the face is visible, we cross another edge until we find a face that is not visible from the current eye point</div>

<div class=blockindent>&nbsp; &#9679; &nbsp; We store the offending edge as part of the horizon and continue the search in the previous face</div>

<div class=blockindent>&nbsp; &#9679; &nbsp; On termination we have a list of all edges defining the horizon in a closed CCW loop</div>

<div class=blockindent>&nbsp; &#9679; &nbsp; On the slide we start at the face labeled with S and follow the arrows and on our way back we collect the horizon edges</div>

<div class=blockindent>&nbsp; &#9679; &nbsp; Since this is an essential operation of the hull construction let‚Äôs look at this step in a bit more detail</div>
<b>Explain arrows in slide!</b><br><br>


<!-- Page 36 -->
<div class="caption"><img src="img/28.png" width=500></div>
I prepared a small animation which hopefully will help to understand the horizon construction:<br>

<!-- Page 37 -->
<div class="caption"><img src="img/29.png" width=500></div>
<div class=blockindent>&nbsp; &#9679; &nbsp; We test the visibility of the next face (and we assume here it is visible from the eye point)</div>
<div class=blockindent>&nbsp; &#9679; &nbsp; Since it is visible we continue our search and cross the next edge</div>

<!-- Page 38 -->
<div class="caption"><img src="img/30.png" width=500></div>
<div class=blockindent>&nbsp; &#9679; &nbsp; We test the next face and since it is visible as well we continue and cross the next edge</div>

<!-- Page 39 -->
<div class="caption"><img src="img/31.png" width=500></div>
<div class=blockindent>&nbsp; &#9679; &nbsp; We continue these tests until we cross an edge to an invisible face</div>

<!-- Page 40 -->
<div class="caption"><img src="img/32.png" width=500></div>
We would now cross an edge to a face we have already visited

<div class=blockindent>&nbsp; &#9679; &nbsp; Whenever we visit a face we will mark them as processed</div>
<div class=blockindent>&nbsp; &#9679; &nbsp; This allows to simply test if a face was already processed and can be skipped</div>

<!-- Page 41 -->
–ü—Ä–æ–¥–æ–ª–∂–∞–µ–º –ø–µ—Ä–µ—Å–µ–∫–∞—Ç—å —Ä–µ–±—Ä–∞...<br>
<div class="caption"><img src="img/33.png" width=500><br>
<img src="img/34.png" width=500><br>
<img src="img/35.png" width=500><br>
<img src="img/36.png" width=500></div>
<!-- Page 45 -->
<div class="caption"><img src="img/37.png" width=500></div>
Again we already visited this face so we don‚Äôt cross this edge as well

<!-- Page 46 -->
<div class="caption"><img src="img/38.png" width=500><br>
<img src="img/39.png" width=500><br>
<img src="img/40.png" width=500></div>
<!-- Page 49 -->
<div class="caption"><img src="img/41.png" width=500></div>
The next face was already visited so no need to cross here too
----------------------- Page 50-----------------------
<div class="caption"><img src="img/42.png" width=500></div>
Finally we would cross the first edge that connects a visible and a non-visible face
<div class=blockindent>&nbsp; &#9679; &nbsp; We add the edge to the horizon list and return to the previous face</div>
----------------------- Page 51-----------------------
<div class="caption"><img src="img/43.png" width=500></div>
We then continue with the next edge and return to the previous face
----------------------- Page 52-----------------------
<div class="caption"><img src="img/44.png" width=500></div>
Again we cross an edge that connects a visible and invisible face
<div class=blockindent>&nbsp; &#9679; &nbsp; We save that edge and add it to our horizon and return to the previous face</div>

----------------------- Page 53-----------------------
<div class="caption"><img src="img/45.png" width=500></div>
The procedure continues and collects the horizon edges until we made our way back to the start face
----------------------- Page 54-----------------------
<div class="caption"><img src="img/46.png" width=500></div>
----------------------- Page 55-----------------------
<div class="caption"><img src="img/47.png" width=500></div>
----------------------- Page 56-----------------------
<div class="caption"><img src="img/48.png" width=500></div>
----------------------- Page 57-----------------------
<div class="caption"><img src="img/49.png" width=500></div>
----------------------- Page 58-----------------------
<div class="caption"><img src="img/50.png" width=500></div>
----------------------- Page 59-----------------------
<div class="caption"><img src="img/51.png" width=500></div>
----------------------- Page 60-----------------------
<div class="caption"><img src="img/52.png" width=500></div>
----------------------- Page 61-----------------------
<div class="caption"><img src="img/53.png" width=500></div>
----------------------- Page 62-----------------------
<div class="caption"><img src="img/54.png" width=500></div>
----------------------- Page 63-----------------------
<div class="caption"><img src="img/55.png" width=500></div>
----------------------- Page 64-----------------------
<div class="caption"><img src="img/56.png" width=500></div>
----------------------- Page 65-----------------------
<div class="caption"><img src="img/57.png" width=500></div>
----------------------- Page 66-----------------------
<div class="caption"><img src="img/58.png" width=500></div>
----------------------- Page 67-----------------------
<div class="caption"><img src="img/59.png" width=500></div>
----------------------- Page 68-----------------------
<div class="caption"><img src="img/60.png" width=500></div>
----------------------- Page 69-----------------------
<div class="caption"><img src="img/61.png" width=500></div>
----------------------- Page 70-----------------------
<div class="caption"><img src="img/62.png" width=500></div>
----------------------- Page 71-----------------------
<div class="caption"><img src="img/63.png" width=500></div>
----------------------- Page 72-----------------------
<div class="caption"><img src="img/64.png" width=500></div>
This is edge we started with and we are done!



----------------------- Page 73-----------------------

On termination we have a list of all horizon edges in CCW order

-   We can now simply create a new triangle face for each horizon edge in our list

-   This essentially connects the new vertex to the current hull



----------------------- Page 74-----------------------

This closes the introduction of the 3D Quickhull algorithm and we continue looking into invariants



----------------------- Page 75-----------------------

As in 2D we must maintain geometric invariants while constructing the hull:

-  In 3D we must now guarantee that every edge  is convex

-  And the argumentation here is basically the same as it was earlier in 2D


----------------------- Page 76-----------------------

We now need to define what a convex edge  is and how we can test an edge for convexity:

For each edge:

-   First we test if the center of the right face is below the left face plane

-   The we test if the center of the left face is below the right face plane

-   If both tests are true the edge is convex, otherwise it must be concave or coplanar

-   This is very similar to the 2D test, but we now use the center point of the face

-   The face center is simply the average of the face vertices


----------------------- Page 77-----------------------

As in 2D we need an epsilon to define the thickness of flat planes and we just expand our formula to 3D!


----------------------- Page 78-----------------------

So when we detect a non-convex edge we now merge the two adjacent faces

-   This adds another step to our iterative loop

-   Let‚Äôs assume face1 and face2 were non-convex in our previous example

-   We would now merge face1 and face2 into a new polygonal face replacing the original faces F1 and F2

-   As mentioned in the beginning we are not restricting ourselves to triangle faces


----------------------- Page 79-----------------------

Let‚Äôs now investigate the example from the original Quickhull  paper:

-   The message of the next slides is really to show what will happened if you DON‚ÄôT merge faces and how you can run into a bunch of geometrical and topological problems!

-   All you need to get here right now is that face merging is really a critical operation !


The situation presents itself like this: Faces F1 and F3 are visible from the new point ùêèwhile face F2 s not!

-   Basically you can think of a simple tetrahedron here

-   The front face is in the screen plane and was  not  merged into one big triangle face,

    but is essentially a fan of three faces

-   It appears to us as if faces F1 ‚Äì  F3 are coplanar

-   But the bad news is that coplanar only exists in an ideal world, but not in the world of limited precision numbers!


----------------------- Page 80-----------------------

What really happens is (and I am exaggerating the situation here a little bit) is that:

-   The two center points are actually moved inside

-   And the edges between F1 and F2 and also F2 and F3 are concave



----------------------- Page 81-----------------------

Now let‚Äôs rotate the tetrahedron and assume we are now looking from behind point P and at the bottom :

-   You can hopefully see the new point and the bottom edges of the three faces

-   Due to the non-convexity the new point gets kind of locked behind the three planes that leads to this weird situation



----------------------- Page 82-----------------------

We continue and build now the horizon as we learned earlier using the DFS

-  The results in five horizon edges a, b, c, d, and e as sketched on the slide



----------------------- Page 83-----------------------

Next we  replace ùêπ  and ùêπ   with 5  new faces for each edge a‚àíe

                    1       3

- Since the outcome of the operation is  pretty interesting let‚Äôs look at each of the new faces individually


----------------------- Page 84-----------------------

We build a face for edge a

-  Note how this face partially overlaps face2 which is still on the hull


----------------------- Page 85-----------------------

We build a face for edge b

-  Note that this face has flipped (CW) orientation and also shares and edge with FA


----------------------- Page 86-----------------------

We build a face for edge c

-   Hooray, nothing wrong here


----------------------- Page 87-----------------------

We build a face for edge d

-  Note that this face has flipped (CW) orientation again and also shares an edge with FA and FB


----------------------- Page 88-----------------------

We build a face for edge e

-  We now have four faces sharing the same edge and also partially overlapping each other


----------------------- Page 89-----------------------
<div class="caption"><img src="img/80.png" width=500></div>
-  Due to numerical imprecision face2 was still identified as visible from P and will remain on the hull


----------------------- Page 90-----------------------

What happened here is that we introduced a couple of severe errors because our hull was not in an healthy state when we started adding the new point.

As a result the new faces are violating a bunch geometrical and topological invariants:

-   Two faces are flipped upside down (that means the  normals are pointing inside)

-   Four faces share the same edge (which make them partially and fully overlapping each other)



As you can imagine repairing those errors would become pretty involved.

The good news are that I haven‚Äôt run into any of the described issues when properly merging faces during the hull construction.

So hopefully you can see that it essential for a robust implementation to maintain a healthy hull during construction.



----------------------- Page 91-----------------------
<h3>Half-Edge mesh</h3>
<div class="caption"><img src="img/81.png" width=500></div>
We haven‚Äôt talked about a data structure for convex  polyhedra yet. So before we start looking into face merging in more detail, let‚Äôs talk about a possible data structure first:

-   Obviously there are many ways to describe a convex polyhedron

-   A common data structure is the so called Half-Edge data structure which is an edge centric mesh representation

-   The half edge data structure makes it easy to iterate edges of a face and to access neighboring faces



For each face we store:

-   A half-edge that defines the entry into a circular list around the face


For each edge we store:

-   The previous and next edge that build the circular list around the face

-   A twin edge to cross over to the adjacent face

-   And the tail vertex of the edge

-   Note that we don‚Äôt need to store the head vertex since it is simple the tail vertex of the twin edge


----------------------- Page 92-----------------------

We learned that face merging is the essential operation to maintain a healthy hull.

-  Here is an example how to merge two faces using the half-edge data structure.

-  The situation is that we are about to merge the left into the right face

-  This means that edge e and its twin will go away and also the left face



----------------------- Page 93-----------------------

First we make sure that the absorbing right face does not reference the edge we are about to delete (e.g. we use edge->prev here)



----------------------- Page 94-----------------------

Next we must make sure that all edges of the absorbed left face will now reference the right face as their owner


----------------------- Page 95-----------------------

Finally we need to connect the incoming and outgoing edges

-   Also note that we can access all necessary data for the merge operation just from the shared edge between the two adjacent faces we are about to merge



----------------------- Page 96-----------------------

The result of two of merged faces is a polygonal face with its vertices  not quite coplanar

-   Remember that we are in the world of limited precision numbers

-   The Newell algorithm builds a best fit plane in the least square sense which minimizes the distance of the vertices


----------------------- Page 97-----------------------

I added some formulas for completeness and convenience, but going into detail here would get us off topic.

-   Both Gino‚Äôs and Christer‚Äôs books cover Newell planes and I also added some additional links in the references


----------------------- Page 98-----------------------

Now let‚Äôs look at one important topological invariant of a convex hull.

-   The most important one for us is that each vertex must have at least three adjacent faces

-   We call a vertex redundant if it does not satisfy this invariant



Of course there are other topological invariants, like:

-   Each face must have at least three neighbors

-   Each edge is shared exactly between two faces

-   Each face of a convex polyhedron must be a convex polygon

-   But as is turns out we don‚Äôt need to deal with those directly


----------------------- Page 99-----------------------

When merging faces we might violate topological invariants and need to fix those:



Consider the merge sequence in the above picture and how it can lead to topological errors:

-   We merge face1 into face3

This creates a couple of problems:

-   Vertex v has now only two adjacent faces and has become redundant

-   Face2 has only two neighbors

-   Face13 is not convex


----------------------- Page 100-----------------------

We detect this error by checking the adjacent faces of the in- and outgoing edges ->

Both edges point to face2

-   Since face2 is a triangle we will not connect the in- and outgoing edge, but use the non-shared edge instead

-   Note that face2 is redundant as well since all vertices are contained in face13 and can be deleted

-   Vertex v has also become obsolete and will be deleted as well

The trick here is that when we merge two faces we check for this error and fix it immediately!



----------------------- Page 101-----------------------

Let‚Äôs look at the previous example again.

Consider now the slightly different merge sequence:

-   We now merge face2 into face1

Again:

-   Vertex v has now only two adjacent faces and has become redundant

-   Besides this I don‚Äôt notice any other problem in this case


----------------------- Page 102-----------------------

We detect this error again by checking the adjacent faces of the in- and outgoing

edges -> Both edges point to face3 here

-   Since face3 has now more than three vertices we cannot apply the same fixing strategy as before

-   Instead we simply extend the incoming edge to the next vertex and delete the outgoing edge

-   Again vertex v has become obsolete and should be deleted as well

Again when we merge faces we check for this error and fix it immediately!


----------------------- Page 103-----------------------

Another problem you will encounter when merging faces is that you might a large number of new faces that should be all merged:

-   Let‚Äôs call this a merge cycle

Imagine we are building the convex of hull of a cylinder and we are about to add the final vertex of the top face:

-   This vertex of course presents itself as in the same plane as the other vertices.

-   In this situation we create many new faces which are roughly coplanar and need to be merged

-   Ideally we would like to merge all new faces into one face as shown on the right hand side


----------------------- Page 104-----------------------

The problem is now that we practically merge one face after the other:

-   Whenever we merge two faces we rebuild the face plane.

-   Rebuilding the face can jiggle the plane and an edge between two faces can become temporarily convex and prevent us from merging the whole cycle

-   In the worst case this can introduce concave faces which are now NOT merged properly



Here are some ideas how to address this:

-   The faces with the largest area should be the most stable w.r.t. the orientation of the face plane. So merging into the largest faces first reduces jiggle. Think of merging the little sister into the big daddy

-   You can also introduce an absolute tolerance to increase your merge radius and make your merge cycle less sensitive for these situations.

-   This is basically how I handle this problem at the moment since for physics we want as large faces as possible for stability reasons and do not aim for the tightest hull.

-   If you are working with collision margins it is probably a good idea to make this absolute tolerance a small percentage of that margin


----------------------- Page 105-----------------------

Another idea to deal with this problem is to NOT rebuild the face planes at all when merging to faces:

-   For both faces you have your best fit plane and the vertices (which I tried to sketch on the slide)

-   We can now compute the absolute distance of the right face‚Äôs vertices to the left face‚Äôs plane and vice versa

-   Then we simply keep the face plane that minimizes the distance instead of rebuilding it

----------------------- Page 106-----------------------

Let‚Äôs close this part how we could use face merging to deal with defect hulls:

-  At each iteration the basic assumption is to start with a healthy hull

-   When adding the vertex we need to inspect all new faces for possible defects at their edges between each other and at the horizon

-   These are the weak spots where might have introduced new errors

-  An easy strategy is to iterate all new faces and repair each edge one by one


----------------------- Page 107-----------------------

This closes the theory and in the remainder of this talk I like to share some quick tips about a possible implementation



----------------------- Page 108-----------------------

The major performance pitfall is bad memory management of the half-edge data structure:

-  The convex hull for N vertices is bounded

-  Worst case is that all input vertices are on the hull:

- The number of vertices is then at most V = N

- The number of edges is then at most E = 3N ‚Äì 6

- The number of faces is then at most F = 2N ‚Äì 4

- Test with Euler‚Äôs formula: V ‚Äì  E + F = 2



In our implementation we can pre-allocate one buffer for vertices, half-edges, and faces and manage this buffer in a free list

-   Ideally we will just have one big allocation per hull construction!

-   This becomes especially important if you plan to compute convex hulls at runtime (e.g. for destruction)



Here are some practical details:

-  Don‚Äôt forget that you need to allocate half-edges (which is twice the number of edges)

- We also need to account for temporary allocations (e.g. horizon faces)

-   In practice I just double the buffer size


----------------------- Page 109-----------------------

Let‚Äôs start with the vertex structure.

-    I am using an intrusive list to store the vertices

-   The vertices are either on the hull or in a conflict list

-    So obviously we have to include the list pointers here.

-   We can optionally also store an edge leaving the vertex.

-   This is not needed for constructing the hull, but it can be useful for post-processing if you like e.g. to iterate all adjacent faces of the vertex

-    Of course we also to need store the position of a vertex

----------------------- Page 110-----------------------

Now let‚Äôs have a quick look how we can potentially implement a half-edge:

-   As we would expect this definition maps pretty directly to a possible data structure

-   We store a pointer to the tail vertex of the edge

-   The half-edges build a circular list around the face so we also need to store the list pointers here

-   And of course we also store the twin edge to cross over to the adjacent face

-    Finally we also keep a reference to the parent face of the edge


----------------------- Page 111-----------------------

Finally the face structure:

-    I am also using an intrusive list here, so we have to include the list pointers again

-    And of course there is a pointer to the first edge starting the circular list around the face

-    Finally it is possibly a good idea to store our conflict list here as well


----------------------- Page 112-----------------------

Finally some high-level code examples to give you an idea of a possible

implementation:

-   Assume we have some qhConvex class to store the hull after construction

-   This snippet shows the top level construction function



Explain a bit‚Ä¶


----------------------- Page 113-----------------------

The code snippets shows the iterative AddVertex() function

-   We add new points until our conflict lists are empty

Explain a bit‚Ä¶


----------------------- Page 114-----------------------

So you want to implement Qhull yourself and I talked now for nearly an hour and

there is no code!

-    Luckily there is a beautiful open-source implementation in JAVA which you can use

    to start

-    I also recommend looking at the original Qhull implementation which is not only a great implementation, but also full of gems of computational geometry!!!

This closes the talk and hopefully my presentation will help you to understand and implement a robust convex hull builder!

Thank you!


----------------------- Page 115-----------------------

Before I close I like to thank a bunch of people!

-   Thanks to Valve for giving me permission to present to you today

-   Thanks to Paul, Steve, Jeff and Anoush for spending time and rehearse this presentation with me

-   Thanks to Randy for reading the presentation several times at an early stage and providing valuable feedback

-   Special thanks to Bruce Dawson for helping with the numerical problems in Quickhull and also providing all kinds of other valuable feedback

-   Special thanks to John Lloyd for sharing his beautiful JAVA Quickhull implementation and making it open source


----------------------- Page 116-----------------------


----------------------- Page 117-----------------------

If you liked this talk and if you want to see more cool Valve presentations please visit out website!



<br><br>
</body></html>
