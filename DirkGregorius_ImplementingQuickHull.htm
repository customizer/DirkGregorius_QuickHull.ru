<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
<title>DirkGregorius_ImplementingQuickHull</title>
<meta http-equiv="content-type" content="text/html; charset=utf-8">
<link rel="stylesheet" type="text/css" href="1.css">
<script type="text/javascript" src="1.js"></script>
</head>
<body>
<a href="https://www.gamedev.net/profile/30524-dirk-gregorius/?tab=activity"><img src="img/Dirk_Gregorius.png" width=150 border=0 align="left" alt="Dirk Gregorius" style="margin-top:-20px;"></a>
<div style="color:#000080; margin-left:220px;"><a href="https://www.gamedev.net/profile/30524-dirk-gregorius/?tab=activity">Dirk Gregorius</a></div>

<h1 style="margin-top:20px; margin-left:200px; margin-bottom:40px;">Реализация быстрого алгоритма выпуклой оболочки<br>
<span style="font-size:70%; margin-left:20px;">Implementing&nbsp;QuickHull</span></h1><br><br>
Добрый день! Меня зовут Дирк, и я инженер-программист в Valve.<br><br>
Некоторые из вас возможно заметили, что я изменил заголовок своей лекции на: "Реализация алгоритма выпуклой оболочки".<br>
Когда я пересказывал эту лекция в Valve, одним из вопросов был: "Почему презентация об алгоритме выпуклой оболочки? Разве это не хорошо понимаемый алгоритм?"<br>
На мой взгляд это отчасти верно. Можно найти несколько презентаций об основах теории выпуклой оболочки и аналитических статей некоторой сложности, но вряд ли
это все имело отношение к реализации данного алгоритма.
Особенно в производственной среде, где приходится иметь дело со всеми видами недостаточно определенной входной геометрией!
Так что, эта лекция будет охватывать, конечно же, основную теорию Quickhull, но также потратим много времени на изучение проблем, с которыми вы можете столкнуться при реализации Quickhull, и способах их решения.<br><br>

<h2>План лекции</h2>
Вначале хотелось бы быстро изложить план лекции:
<div class=blockindent>&nbsp; &#9679; &nbsp; После короткого вступления сначала будет разговор об алгоритме выпуклой оболочки (Quickhull) в двумерном пространстве.</div>
<div class=blockindent>&nbsp; &#9679; &nbsp; Затем продолжим описание с геометрическими постоянными (инвариантами), которых нужно придерживаться при построении оболочки, во избежание проблем с вычислениями.</div>
<div class=blockindent>&nbsp; &#9679; &nbsp; После знакомства с двумерным вариантом, тут же погружаемся в трехмерную версию быстрой оболочки.</div>
<div class=blockindent>&nbsp; &#9679; &nbsp; Затем исследуем геометрические и топологические инварианты при построении оболочки в трехмерном пространстве и
We then investigate geometrical and topological invariants while constructing the hull in 3D and close with some implementation details.</div><br>

<h3>Выпуклость</h3>
Прежде чем начать, давайте выясним, что такое выпуклая оболочка и рассмотрим пример:
<div class=blockindent>&nbsp; &#9679; &nbsp; Фигура называется выпуклой, если для любых двух точек, которые находятся <b>внутри</b> фигуры, линия между этими двумя точками также находится внутри.</div>
<div class=blockindent>&nbsp; &#9679; &nbsp; Если посмотреть на случай с вогнутой фигурой, то легко можно найти внутри фигуры две точки, линия между которыми выходит за контур фигуры и затем снова входит в неё.</div>
<table width=90%><tr><td width=50%><div class="caption"><img src="img/1a.png" width=250><br>Выпуклая фигура (convex)</div></td>
<td width=50%><div class="caption"><img src="img/1b.png" width=250><br>Вогнутая фигура (concave)</div></td></tr></table><br><br>

<h3>Выпуклые оболочки</h3>
Что такое выпуклая оболочка (convex hull)?<br>
Задав набор из энного числа входных точек можно определить, что можно называть выпуклой оболочкой:
<div class=blockindent>&nbsp; &#9679; &nbsp; Официальное определение: выпуклая оболочка это наименьший выпуклый набор, содержащий все входные точки.</div>
<div class=blockindent>&nbsp; &#9679; &nbsp; По простому: Если все точки представить в виде гвоздей, вбитых в деревянную дощечку, то выпуклая оболочка будет резинкой, натянутой вокруг внешних гвоздей.</div>
<div class="caption"><img src="img/2.png" width=250><br>Набор точек в двумерном пространстве и его выпуклая оболочка</div><br>
<b>Это означает, что в двумерном пространстве оболочкой является многоугольник (полигон), определяемый вершинами и ребрами!</b><br><br>

Также хочется показать трехмерную выпуклую оболочку вокруг хорошо известного объекта - чайника Юта (Utah Teapot).
<div class=blockindent>&nbsp; &#9679; &nbsp; В двумерном пространстве для получения некоего понимания о выпуклой оболочке в качестве аналога использовалось кольцо резинки.</div>
<div class=blockindent>&nbsp; &#9679; &nbsp; В трехмерном пространстве выпуклую оболочку можно рассматривать как упаковку объекта плотно обтягивающей пленкой.</div>
<div class="caption"><img src="img/3.png" width=600></div><br>
<b>В трехмерном пространстве оболочкой является многогранник, определяемый вершинами, ребрами и многоугольными (полигональными) гранями! Обратите внимание, что мы не собираемся ограничиваться только треугольными гранями!</b><br><br>

<h4>Использование выпуклых оболочек для обнаружения столкновений</h4>
Почему следует использовать выпуклые оболочки для обнаружения столкновений в играх?
<div class=blockindent>&nbsp; &#9679; &nbsp; Динамические объекты в играх используют приближение к простым формам для обнаружения столкновений поскольку использование отображения геометрического элемента <b>не будет</b> эффективным с точки зрения производительности.</div>
<div class=blockindent>&nbsp; &#9679; &nbsp; Выпуклые оболочки - хороший кандидат на замену, поскольку они могут достаточно хорошо соответствовать даже сложному геометрическому элементу.</div>
<div class=blockindent>&nbsp; &#9679; &nbsp; Кроме того, обнаружение столкновений для выпуклых многогранников хорошо и надежно определяется. Вспомните о <a href="https://ru.wikipedia.org/wiki/%D0%90%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC_%D0%93%D0%B8%D0%BB%D0%B1%D0%B5%D1%80%D1%82%D0%B0_%E2%80%94_%D0%94%D0%B6%D0%BE%D0%BD%D1%81%D0%BE%D0%BD%D0%B0_%E2%80%94_%D0%9A%D1%91%D1%80%D1%82%D0%B8" onmouseover="show('GJK - сокращ. от англ. слов Gilbert—Johnson—Keerthi algorithm<br>(алгоритм Гилберта—Джонсона—Кёрти) — алгоритм для<br>определения минимального расстояния между двумя<br>выпуклыми множествами (объектами)')" onmouseout="hide()">GJK</a> и
<a href="https://ru.wikipedia.org/wiki/%D0%A2%D0%B5%D0%BE%D1%80%D0%B5%D0%BC%D0%B0_%D0%BE%D0%B1_%D0%BE%D0%BF%D0%BE%D1%80%D0%BD%D0%BE%D0%B9_%D0%B3%D0%B8%D0%BF%D0%B5%D1%80%D0%BF%D0%BB%D0%BE%D1%81%D0%BA%D0%BE%D1%81%D1%82%D0%B8" onmouseover="show('SAT - сокращ. от англ. слов Separating Axis Theorem<br>(теорема разделяющей оси) для двух выпуклых объектов<br>можно сформулировать так: два выпуклых объекта<br>пересекаются тогда и только тогда, когда существует<br>плоскость (для двумерного случая - прямая), такая,<br>что одна геометрия лежит по одну её сторону, а другая<br>- по другую')" onmouseout="hide()">SAT</a>, которые мы обсуждали уже здесь в предыдущих руководствах.
<!-- http://www.dyn4j.org/2010/01/sat/ --></div><br>

<h4>Использование выпуклых оболочек в игре</h4>
<div class="caption"><img src="img/4.png" width=600></div><br>
Прежде чем начать, хочется показать два видеоролика, чтобы было представление о том, как выпуклые оболочки используются в играх:
<div class=blockindent>&nbsp; &#9679; &nbsp; Показать видеоролик о выпуклых оболочках в игре.</div>
<div class=blockindent>&nbsp; &#9679; &nbsp; Показать, как физический движок рассматривает игру.</div>

Sergiy will show you how to implement awesome physics visualization right after this talk!<br><br>
Надеюсь что видеоролики дали общее представление проблемы, которую мы попытаемся здесь решить.<br><br>


Когда я начал присматриваться к построению выпуклых оболочек, то быстро наткнулся на алгоритм под названием Quickhull:
<div class=blockindent>&nbsp; &#9679; &nbsp; Quickhull был выпущен в 1995 году Barber и Dobkin.</div>
<div class=blockindent>&nbsp; &#9679; &nbsp; По существу это пошаговый (итеративный) алгоритм, который добавляет отдельные точки (по одной за раз) к промежуточной оболочке.</div>
<div class=blockindent>&nbsp; &#9679; &nbsp; При реализации алгоритма для построения выпуклых оболочек приходится иметь дело с входной геометрией, которая сталкивается с ограничением точности вычислений с плавающей запятой.</div>
<div class=blockindent>&nbsp; &#9679; &nbsp; Для решения этих проблем Quickhull использует так называемые "толстые" плоскости и объединение граней.</div>
<div class=blockindent>&nbsp; &#9679; &nbsp; В результате работы алгоритма появляется набор "толстых" граней, которые ограничивают конкретную выпуклую оболочку.</div>
В последующей части лекции попробуем подробно разъяснить, что это значит!<br><br>

<!-- Page 9 -->
Знакомство с алгоритмом начнем с его варианта в 2D пространстве.
<div class=blockindent>&nbsp; &#9679; &nbsp; Хотелось бы отметить, что это не "реальный" алгоритм Quickhull для 2D пространства (который существует на самом деле).
Следует думать о нем как о вводной части в трехмерную версию, которая позже будет рассмотрена в этой статье.</div>
<div class=blockindent>&nbsp; &#9679; &nbsp; Лично я считаю, что зачастую полезно сначала рассмотреть все эти вещи в 2D, чтобы ознакомиться с основными идеями и хорошо понять задачу.</div><br><br>

<!-- Page 10 -->
<h2>Quickhull 2D: Инициализация оболочки</h2>
Предположим, что задан набор точек, и нужно построить выпуклую оболочку с использованием алгоритма Quickhull:
<div class=blockindent>&nbsp; &#9679; &nbsp; Первое, что нужно сделать в Quickhull, - это построить исходную оболочку, из которой можно начать пошагово добавлять точки.</div>
<div class="caption"><img src="img/5.png" width=400></div>
Поиск этой исходной оболочки начнем с определения крайних точек по каждой из осей координат.
<div class=blockindent>&nbsp; &#9679; &nbsp; Если по простому, то это означает, что нужно найти точки с наибольшими и наименьшими значениями координат&nbsp;<tt>x</tt>&nbsp;и&nbsp;<tt>y</tt>.</div>
<div class="caption"><img src="img/6.png" width=580></div>
Из этих четырех точек выбираем пару, в которой точки находятся на самом большом расстоянии друг от друга.
<div class=blockindent>&nbsp; &#9679; &nbsp; В данном примере это будут самая левая и самая правая точки.</div>
<div class="caption"><img src="img/7.png" width=400></div>
Наконец, мы ищем самую дальнюю точку от линии, проведенной через эти две крайние точки
<div class="caption"><img src="img/8.png" width=400></div>
Эти три точки и дадут нашу первоначальную оболочку.
<div class=blockindent>&nbsp; &#9679; &nbsp; Первоначальная оболочка в двумерном пространстве - это просто треугольник.</div>
<div class="caption"><img src="img/9.png" width=400></div><br><br>

<h3>Quickhull 2D: Разделение точек</h3>
Прежде чем начать добавлять новые точки к исходной оболочке, нужно сделать некоторые бухгалтерские работы:
<div class=blockindent>&nbsp; &#9679; &nbsp; Следующим шагом будет разделение оставшихся точек и закрепление каждой точки за ближайшей к ней гранью.</div>
<div class=blockindent>&nbsp; &#9679; &nbsp; Также можно удалить точки внутри исходной оболочки, поскольку они не могут быть на финальном варианте оболочки.</div>
<div class="caption"><img src="img/10.png" width=650><br>
Пояснение к коду на картинке: <tt>CL</tt> - сокращ. англ. слов conflict list - список конфликтов, а <tt>CL(e1)={p1, p2, p3}</tt> означает, что список конфликтов грани <tt>e1</tt> содержит точки <tt>p1</tt>, <tt>p2</tt> и <tt>p3</tt>.</div><br>

Это означает, что каждая грань ведет список точек, которые находятся вне плоскости грани. Эти списки называются «списками конфликтов», поскольку точки могут «видеть» эту грань и следовательно, возможно находятся на финальном варианте оболочки.
Это грамотный способ управления вершинами, поскольку при добавлении к оболочке новой вершины не нужно перебирать все вершины.
Поэтому <a href="https://ru.wikipedia.org/wiki/%D0%92%D1%80%D0%B5%D0%BC%D0%B5%D0%BD%D0%BD%D0%B0%D1%8F_%D1%81%D0%BB%D0%BE%D0%B6%D0%BD%D0%BE%D1%81%D1%82%D1%8C_%D0%B0%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D0%B0" target="_blank">временна&#769;я сложность алгоритма</a>
Quickhull обычно равна <span class="lnk" onmouseover="show('линейно-логарифмическое время,<br>максимально быстрая сортировка<br>сравнением')" onmouseout="hide()"><tt>O(n log n)</tt></span> как в двумерном, так и в трехмерном вариантах!
<div class=warning><b>Предупреждение:</b> Пожалуйста не запутайтесь здесь. Так как алгоритм представлен в двух- и трехмерном вариантах и некоторая терминология совпадает, будем использовать термины «Edge» (ребро, край) и «Face» (грань) как взаимозаменяемые! Это поможет, когда позже в этой лекции перейдем к трехмерному варианту алгоритма!</div>
<div class=note_trans><b>Примечание переводчика:</b> В двумерном пространстве ребром будет простая линия, в отличие от трехмерного пространства, где ребро - это граница между двумя смежными гранями.<br>
Двумерная грань - это часть плоскости между двумя ребрами-линиями, в трехмерном пространстве, грань - это плоскость между ребрами.</div><br><br>


<h3>Quickhull 2D: Поиск следующей вершины</h3>
Следующим шагом будет добавление новой точки к нашему промежуточному варианту оболочки. Перебираем наши списки конфликтов и находим точку <b>p</b> с наибольшим расстоянием от этой оболочки.
<div class=blockindent>&nbsp; &#9679; &nbsp; Давайте назовем эту точку точкой просмотра или обзора.</div>
<div class=blockindent>&nbsp; &#9679; &nbsp; Добавление этой новой точки потребует несколько дополнительных шагов.</div>
<div class="caption"><img src="img/11.png" width=400></div><br>

<h3>Quickhull 2D: Поиск горизонта</h3>
<div class="caption"><img src="img/12.png" width=580></div>
Сначала нам нужно определить все грани, которые видны из недавно добавленной точки, поскольку эти грани могут находиться не на оболочке:

<div class=blockindent>&nbsp; &#9679; &nbsp; Грань является видимой, если эта новая точка находится перед плоскостью грани. A face is visible if the new point is in front of the face plane.</div>

<div class=blockindent>&nbsp; &#9679; &nbsp; Можно воспользоваться простыми проверками плоскости чтобы причислить эту новую точку по отношению к каждой грани!
We can use simple plane tests to classify the new point against each face!</div>

<div class=blockindent>&nbsp; &#9679; &nbsp; Следующий шаг состоит в том, чтобы найти две вершины, соединяющие видимую грань с невидимой.</div>
<div class=blockindent>&nbsp; &#9679; &nbsp; Эти две вершины (<tt>H1</tt> и <tt>H2</tt>) называются горизонтом.</div>
<div class=blockindent>&nbsp; &#9679; &nbsp; Фактически, горизонт является границей между видимой и невидимой частями текущей оболочки, как оно видится из новой точки просмотра.</div><br>

<h3>Quickhull 2D: Добавление точки к оболочке</h3>
После определения двух вершин горизонта, для присоединения новой вершины к оболочке создадим две новые грани от каждой вершины горизонта.
<div class="caption"><img src="img/13.png" width=400></div><br><br>

<!-- Page 19 -->
<h3>Quickhull 2D: Переопределение "осиротевших" точек</h3>
После построения новых граней некоторые старые грани стали ненужными.
<div class=blockindent>&nbsp; &#9679; &nbsp; Прежде чем удалить эти грани, нужно обработать их списки конфликтов, поскольку конфликтные точки в этих списках могут оставаться на финальном варианте оболочки.</div>
<div class=blockindent>&nbsp; &#9679; &nbsp; Обработка заключается в простом переопределении этих "осиротевших" вершин к новым граням.</div>
<div class="caption"><img src="img/14.png" width=600></div><br><br>

<!-- Page 20 -->
<h3>Quickhull 2D: Добавление точки к оболочке</h3>
Наконец, теперь можно удалить все старые грани, которые были видны из новой точки и, следовательно, больше не могут находиться на оболочке.
<div class=blockindent>&nbsp; &#9679; &nbsp; На этом заканчивается данный цикл итераций и далее мы повторяем эти шаги до тех пор, пока не опустеют все списки конфликтов.</div>

<div class=blockindent>&nbsp; &#9679; &nbsp; В нашем примере действие продолжается и захватывается следующая точка просмотра и добавляется к оболочке точно также, как мы только что узнали.
In our example we continue and grab the next eye point and add it to hull as we just learned</div>
<div class="caption"><img src="img/15.png" width=400></div>

<!-- Page 21 -->
И, чтобы найти наш финальный вариант оболочки, делаем это ещё раз ...
<div class="caption"><img src="img/16.png" width=400></div>

<!-- Page 22 -->
<h3>Quickhull 2D:</h3>
И вот, нет больше вершин (все списки конфликтов пусты) и все закончилось!
<div class="caption"><img src="img/17.png" width=400></div><br><br>

<!-- Page 23 -->
Как можно было видеть, все основные идеи были довольно просты для понимания.
<div class=blockindent>&nbsp; &#9679; &nbsp; В 3D варианте алгоритма основные трудности реализации фактически возникают из-за управления списками вершин, ребер, граней и конфликтов.</div>
<div class=blockindent>&nbsp; &#9679; &nbsp; Другая сложность связана с неточностью в вычислениях при классификации точек с использованием проверок плоскости.</div>

<!-- Page 24 -->
До сих пор мы делали вид, что наши математические операции точны.
So far we pretended that our mathematical operations are exact

<div class=blockindent>&nbsp; &#9679; &nbsp; Конечно, это * не * верно в арифметике с плавающей запятой.
Of course this is *not* true in floating point arithmetic.</div>

<div class=blockindent>&nbsp; &#9679; &nbsp; Давайте расследуем, как можно справиться с этими проблемами.
Let’s investigate how we can deal with those problems.</div><br><br>

<!-- Page 25 -->
<h3>Quickhull 2D: Инварианты</h3>
<div class=note_trans><b>Примечание переводчика:</b> Инвариант — это свойство некоторого класса (множества) математических объектов, остающееся неизменным при преобразованиях определённого типа. В топологии — это величина, определённая для каждого узла и одинаковая для эквивалентных узлов.</div>
При построении выпуклой оболочки следует придерживаться геометрических инвариантов.
<div class=blockindent>&nbsp; &#9679; &nbsp; В двумерном варианте алгоритма должна быть обеспечена выпуклость каждой вершины.</div>
<div class=blockindent>&nbsp; &#9679; &nbsp; Это должно быть очевидно, так как в противном случае было бы легко найти прямую между двумя точками внутри оболочки, которая бы выходила из нее и вновь входила, как показано на рисунке в начале статьи.</div>
<div class=blockindent>&nbsp; &#9679; &nbsp; На рисунке это подсказывается пунктирной линией между нормалями, проведенными от оболочки наружу. Как видите, на верхнем рисунке она проходит внутри оболочки (т.е. оболочка выпуклая), а на нижнем - снаружи (оболочка вогнутая).</div>
<div class="caption"><img src="img/18.png" width=600><br>vertex V is convex - вершина V выпуклая, vertex V is concave - вершина V вогнутая</div><br><br>

<!-- Page 26 -->
<h3>Quickhull 2D: Проверка на выпуклость</h3>
Далее нужно определить, что такое выпуклая вершина и как мы можем проверить вершину на выпуклость:<br>
Для каждой вершины:
<div class=blockindent>&nbsp; &#9679; &nbsp; Вначале проверяем, находится ли правая вершина ниже левой грани.</div>
<div class=blockindent>&nbsp; &#9679; &nbsp; Затем проверяем, находится ли левая вершина ниже правой грани.</div>
<div class=blockindent>&nbsp; &#9679; &nbsp; Если обе проверки в итоге дали значение <tt>true</tt> (истина), вершина выпуклая, в противном случае она должна быть либо вогнутая, либо копланарная.</div>
<div class="caption"><img src="img/19.png" width=600><br>left face test - проверка левой грани, right face test - проверка правой грани</div><br><br>

<!-- Page 27 -->
<h3>Quickhull 2D: Надежность вычислений</h3>
Теперь давайте рассмотрим пример, в котором невыпуклые вершины могут стать проблемой:
<div class=blockindent>&nbsp; &#9679; &nbsp; Всякий раз, когда добавляется точка, которая находится на одной линии с существующей гранью (т.е. <a href="https://ru.wikipedia.org/wiki/%D0%9A%D0%BE%D0%BB%D0%BB%D0%B8%D0%BD%D0%B5%D0%B0%D1%80%D0%BD%D0%BE%D1%81%D1%82%D1%8C" target="_blank">колинеарна</a>), некоторые вещи могут стать неопределенными.</div>
<div class=blockindent>&nbsp; &#9679; &nbsp; Небольшое изменение точки <tt>P</tt> будет определять, останется ли вершина <tt>V</tt> на оболочке или нет.</div>
<div class=blockindent>&nbsp; &#9679; &nbsp; В идеале хотелось бы иметь более стабильную ситуацию, так чтобы при очень небольших изменениях в пределах некоторого допуска получался бы одинаковый результат.</div>
<div class=blockindent>&nbsp; &#9679; &nbsp; Заметим, что точка <tt>P</tt> на самом деле не движется, но может оказаться по обе стороны от плоскости <b>просто</b> из-за неточности в вычислениях.</div>
<div class="caption"><img src="img/20.png" width=600><br>
coplanar - копланарный, т.е. находящийся в одной плоскости, concave - вогнутый, convex - выпуклый</div><br><br>

<!-- Page 28 -->
<h3>Quickhull 2D: "Толстые" плоскости</h3>
Общим подходом к решению таких типовых задач является использование так называемых <b>толстых</b> плоскостей.
<div class=blockindent>&nbsp; &#9679; &nbsp; Вместо сравнения непосредственно с нулем мы теперь сравниваем с некоторым значением эпсилон (&#949;).</div>
По-прежнему можно распределять точки при использовании "толстых" плоскостей, как и раньше:
<div class=blockindent>&nbsp; &#9679; &nbsp; Точка находится перед плоскостью, если расстояние между этой точкой и плоскостью больше значения эпсилон.</div>
<div class=blockindent>&nbsp; &#9679; &nbsp; Точка находится позади плоскости, если расстояние между этой точкой и плоскостью меньше отрицательного значения эпсилон.</div>
<div class=blockindent>&nbsp; &#9679; &nbsp; Во всех остальных случаях точка должна быть на плоскости.</div>
<div class="caption"><img src="img/21.png" width=600><br>
in front of plane - перед плоскостью, behind plane - за плоскостью, on plane - на плоскости</div><br>
<b>Теперь можно устанавливать что вершина является выпуклой, если расстояние между ней и плоскостью больше значения эпсилон. Все остальные точки являются либо вогнутыми, либо копланарными и должны обрабатываться отдельно!</b><br><br>

<!-- Page 29 -->
<h3>Quickhull 2D: Объединение граней</h3>
Итак, что делать, при встрече с невыпуклой вершиной?
<div class=blockindent>&nbsp; &#9679; &nbsp; Правило состоит в том, чтобы каждая вершина нашей оболочки была однозначно выпуклой.</div>
<div class=blockindent>&nbsp; &#9679; &nbsp; Можно применять это правило, просто объединяя левую и правую грань через невыпуклую вершину в новую грань.</div>
<div class=blockindent>&nbsp; &#9679; &nbsp; Как можно видеть на рисунке, при этом удаляется вогнутость и исправляется геометрический дефект.</div>
<div class="caption"><img src="img/22.png" width=500><br>non-convex - невыпуклая, merged - объединенная</div><br><br>

<!-- Page 30 -->
<h3>Quickhull 2D: Epsilon</h3>
<div class="caption"><img src="img/23.png" width=400></div>
Последний вопрос: какое значение эпсилон следует выбрать для наших "толстых" плоскостей:

<div class=blockindent>&nbsp; &#9679; &nbsp; CRT определяет epsilon с плавающей запятой, но это НЕ учитывает наш входной набор.
The CRT defines a floating point epsilon but this does NOT take our input set into account.</div>

<div class=blockindent>&nbsp; &#9679; &nbsp; Хотелось бы определять относительный допуск принимая во внимание размер входного объекта.</div>

<div class=blockindent>&nbsp; &#9679; &nbsp; Таким образом, одно из возможных решений - выбрать значение эпсилон исходя из суммы максимальных абсолютных координат.
So one possible solution it to choose an epsilon relative to the sum of maximum absolute coordinates</div>

<div class=blockindent>&nbsp; &#9679; &nbsp; Обратите внимание, что при использовании FLT_EPSILON без масштабирования мы потерпим неудачу, например, очень маленькие модели (где FLT_EPSILON намного больше, чем сама модель).
Note that when using FLT_EPSILON without scaling we would fail big time e.g. very small models (where FLT_EPSILON is much bigger than the entire model itself)</div>
<!-- FLT_EPSILON	1.192092896e-07F	Наименьшее число такое, что 1.0+FLT_EPSILON !=1.0
Разница между единицей и наименьшим значением, большим единицы, которую можно представить в виде числа с плавающей запятой.
https://ru.wikipedia.org/wiki/%D0%9C%D0%B0%D1%88%D0%B8%D0%BD%D0%BD%D1%8B%D0%B9_%D0%BD%D0%BE%D0%BB%D1%8C    машинный ноль
https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Number/EPSILON -->

<div class=blockindent>&nbsp; &#9679; &nbsp; Или для очень больших моделей, когда значение эпсилон слишком мало, чтобы иметь вообще какое-либо значение.
Or for very large models where the epsilon is too small to make any difference at all</div><br><br>


<!-- Page 31 -->
На этом знакомство с двумерным вариантом алгоритма Quickhull заканчивается:
<div class=blockindent>&nbsp; &#9679; &nbsp; Надеюсь, что у вас появилось первое представление о работе алгоритма.</div>
<div class=blockindent>&nbsp; &#9679; &nbsp; Для двумерного пространства уже имеются хорошие алгоритмы построения выпуклых оболочек, которые легко и просто реализовать.</div>
<div class=blockindent>&nbsp; &#9679; &nbsp; Так что, если ваша игра двумерна, рекомендую использовать один из них.</div><br>

В оставшейся части обсуждения рассмотрим, как создаются выпуклые оболочки в 3D пространстве.
<div class=blockindent>&nbsp; &#9679; &nbsp; Алгоритм Quickhull в 3D очень похож на версию, которая только что показана в описании 2D-варианта.</div>
<div class=blockindent>&nbsp; &#9679; &nbsp; Наиболее заметным отличием является построение горизонта и мы должны иметь дело с числовой неточностью более тщательно
The most notable difference is the construction of the horizon and we  have to deal with numerical imprecision more carefully</div><br><br>

<!-- Page 32 -->
<img src="img/24.png" width=250 align=right>
<h3>Quickhull 3D: Начальная оболочка</h3>
Также как и в двумерном варианте, сперва нужно построить начальную, исходную оболочку.
<div class=blockindent>&nbsp; &#9679; &nbsp; Также как это делалось в 2D, вначале нужно найти исходный треугольник <tt>(v1, v2, v3)</tt>.</div>
<div class=blockindent>&nbsp; &#9679; &nbsp; Затем, точно также добавим самую дальнюю точку от треугольной плоскости (здесь это <tt>v4</tt>).</div>
<div class=blockindent>&nbsp; &#9679; &nbsp; В 3D пространстве исходная оболочка теперь представляет собой тетраэдр.</div>
<div class=blockindent>&nbsp; &#9679; &nbsp; После построения исходной оболочки, далее разделим оставшиеся точки в списках конфликтов граней нашей исходной оболочки.</div><br><br>


<!-- Page 33 -->
<h3>Quickhull 3D: Горизонт</h3>
<div class="caption"><img src="img/25.png" width=600></div>
We then start iteratively adding new points to the hull and grab the point with the largest distance from our conflict lists:

<div class=blockindent>&nbsp; &#9679; &nbsp; This will give us the next eye point</div>

<div class=blockindent>&nbsp; &#9679; &nbsp; As in 2D we need to find the horizon again</div>

<div class=blockindent>&nbsp; &#9679; &nbsp; In 3D the horizon is a list of edges that connect visible with non-visible faces.</div>

<div class=blockindent>&nbsp; &#9679; &nbsp; And again the horizon is the boundary between the visible and non–visible part of the current hull as seen from the current eye point</div>

<div class=blockindent>&nbsp; &#9679; &nbsp; Finding the horizon is a bit more involved in 3D and we will look at it in more detail in just a second</div>


<!-- Page 34 -->
<h3>Quickhull 3D: Добавление точки к оболочке</h3>
<div class="caption"><img src="img/26.png" width=600></div>
We then proceed with the iteration and create a new face for each horizon edge with the new eye-point

<div class=blockindent>&nbsp; &#9679; &nbsp; This essentially connects the new vertex to the current hull</div>

<div class=blockindent>&nbsp; &#9679; &nbsp; Finally we partition the orphaned vertices to the new faces (F1 –  F3)</div>


<!-- Page 35 -->
<h3>Quickhull 3D: Поиск горизонта</h3>
<div class="caption"><img src="img/27.png" width=500></div>
Найти горизонт в трехмерном пространстве не так просто, как это было при поиске двух вершин в 2D пространстве.

<div class=blockindent>&nbsp; &#9679; &nbsp; Для нахождения горизонта по существу выполняется <a href="https://ru.wikipedia.org/wiki/%D0%9F%D0%BE%D0%B8%D1%81%D0%BA_%D0%B2_%D0%B3%D0%BB%D1%83%D0%B1%D0%B8%D0%BD%D1%83" onmouseover="show('DFS - сокращ. англ. слов depth-first search - поиск<br>в глубину, один из методов обхода графа')" onmouseout="hide()">DFS</a>, начиная с
For finding the horizon we essentially perform a DFS starting from the conflict face S</div>

<div class=blockindent>&nbsp; &#9679; &nbsp; При каждом шаге мы пересекаем одно ребро и переходим на соседнюю, смежную грань.</div>

<div class=blockindent>&nbsp; &#9679; &nbsp; If the face is visible, we cross another edge until we find a face that is not visible from the current eye point</div>

<div class=blockindent>&nbsp; &#9679; &nbsp; We store the offending edge as part of the horizon and continue the search in the previous face</div>

<div class=blockindent>&nbsp; &#9679; &nbsp; On termination we have a list of all edges defining the horizon in a closed CCW loop</div>

<div class=blockindent>&nbsp; &#9679; &nbsp; On the slide we start at the face labeled with S and follow the arrows and on our way back we collect the horizon edges</div>

<div class=blockindent>&nbsp; &#9679; &nbsp; Since this is an essential operation of the hull construction let’s look at this step in a bit more detail</div>
<b>Explain arrows in slide!</b><br><br>


<!-- Page 36 -->
<div class="caption"><img src="img/28.png" width=500></div>
I prepared a small animation which hopefully will help to understand the horizon construction:<br>

<!-- Page 37 -->
<div class="caption"><img src="img/29.png" width=500></div>
<div class=blockindent>&nbsp; &#9679; &nbsp; We test the visibility of the next face (and we assume here it is visible from the eye point)</div>
<div class=blockindent>&nbsp; &#9679; &nbsp; Since it is visible we continue our search and cross the next edge</div>

<!-- Page 38 -->
<div class="caption"><img src="img/30.png" width=500></div>
<div class=blockindent>&nbsp; &#9679; &nbsp; We test the next face and since it is visible as well we continue and cross the next edge</div>

<!-- Page 39 -->
<div class="caption"><img src="img/31.png" width=500></div>
<div class=blockindent>&nbsp; &#9679; &nbsp; We continue these tests until we cross an edge to an invisible face</div>

<!-- Page 40 -->
<div class="caption"><img src="img/32.png" width=500></div>
We would now cross an edge to a face we have already visited

<div class=blockindent>&nbsp; &#9679; &nbsp; Whenever we visit a face we will mark them as processed</div>
<div class=blockindent>&nbsp; &#9679; &nbsp; This allows to simply test if a face was already processed and can be skipped</div>

<!-- Page 41 -->
Продолжаем пересекать ребра...<br>
<div class="caption"><img src="img/33.png" width=500><br>
<img src="img/34.png" width=500><br>
<img src="img/35.png" width=500><br>
<img src="img/36.png" width=500></div>
<!-- Page 45 -->
<div class="caption"><img src="img/37.png" width=500></div>
Again we already visited this face so we don’t cross this edge as well

<!-- Page 46 -->
<div class="caption"><img src="img/38.png" width=500><br>
<img src="img/39.png" width=500><br>
<img src="img/40.png" width=500></div>
<!-- Page 49 -->
<div class="caption"><img src="img/41.png" width=500></div>
The next face was already visited so no need to cross here too
<!-- Page 50 -->
<div class="caption"><img src="img/42.png" width=500></div>
Finally we would cross the first edge that connects a visible and a non-visible face
<div class=blockindent>&nbsp; &#9679; &nbsp; Добавляем ребро в список горизонта и возвращаемся к предыдущей грани.
We add the edge to the horizon list and return to the previous face</div>
<!-- Page 51 -->
<div class="caption"><img src="img/43.png" width=500></div>
Затем переходим к следующему ребру и возвращаемся к предшествующей ему грани.
We then continue with the next edge and return to the previous face
<!-- Page 52 -->
<div class="caption"><img src="img/44.png" width=500></div>
Again we cross an edge that connects a visible and invisible face
<div class=blockindent>&nbsp; &#9679; &nbsp; We save that edge and add it to our horizon and return to the previous face</div>

<!-- Page 53 -->
Процедура продолжается и собирает края горизонта, пока не возвратимся к начальной грани.
<div class="caption"><img src="img/45.png" width=500></div>

The procedure continues and collects the horizon edges until we made our way back to the start face
----------------------- Page 54-----------------------
<div class="caption"><img src="img/46.png" width=500></div>
<div class="caption"><img src="img/47.png" width=500></div>
<div class="caption"><img src="img/48.png" width=500></div>
<div class="caption"><img src="img/49.png" width=500></div>
<div class="caption"><img src="img/50.png" width=500></div>
<div class="caption"><img src="img/51.png" width=500></div>
<div class="caption"><img src="img/52.png" width=500></div>
<div class="caption"><img src="img/53.png" width=500></div>
<div class="caption"><img src="img/54.png" width=500></div>
<div class="caption"><img src="img/55.png" width=500></div>
<div class="caption"><img src="img/56.png" width=500></div>
<div class="caption"><img src="img/57.png" width=500></div>
<div class="caption"><img src="img/58.png" width=500></div>
<div class="caption"><img src="img/59.png" width=500></div>
<div class="caption"><img src="img/60.png" width=500></div>
<div class="caption"><img src="img/61.png" width=500></div>
<div class="caption"><img src="img/62.png" width=500></div>
<div class="caption"><img src="img/63.png" width=500></div>
Это то ребро, с которого все начиналось и вот все готово!
<div class="caption"><img src="img/64.png" width=500></div><br>
<!-- Page 73 -->
По завершении действия мы имеем список всех ребер горизонта в направлении против часовой стрелки.
<div class="caption"><img src="img/65.png" width=500></div>
<div class=blockindent>&nbsp; &#9679; &nbsp; Теперь можно запросто создать новую треугольную грань для любого ребра горизонта нашего списка.</div>
<div class=blockindent>&nbsp; &#9679; &nbsp; По существу это будет присоединением новой вершины к текущей оболочке.</div><br>

<!-- Page 74 -->
На этом знакомство с алгоритмом Quickhull 3D завершается, а продолжается изучение инвариантов.
This closes the introduction of the 3D Quickhull algorithm and we continue looking into invariants<br><br>

<!-- Page 75 -->
<h3>Quickhull 3D: Invariants</h3>
As in 2D we must maintain geometric invariants while constructing the hull:
<div class="caption"><img src="img/66.png" width=500><br>на верхнем рисунке ребро <b>e</b> выпуклое, на нижнем - вогнутое</div>
<div class=blockindent>&nbsp; &#9679; &nbsp; In 3D we must now guarantee that every edge  is convex</div>

<div class=blockindent>&nbsp; &#9679; &nbsp; And the argumentation here is basically the same as it was earlier in 2D</div>

<!-- Page 76 -->
We now need to define what a convex edge  is and how we can test an edge for convexity:
<div class="caption"><img src="img/67.png" width=500><br>на верхнем рисунке - проверка левой грани, на нижнем - проверка правой грани</div>
Для каждого ребра:

<div class=blockindent>&nbsp; &#9679; &nbsp; First we test if the center of the right face is below the left face plane</div>

<div class=blockindent>&nbsp; &#9679; &nbsp; The we test if the center of the left face is below the right face plane</div>

<div class=blockindent>&nbsp; &#9679; &nbsp; If both tests are true the edge is convex, otherwise it must be concave or coplanar</div>

<div class=blockindent>&nbsp; &#9679; &nbsp; This is very similar to the 2D test, but we now use the center point of the face</div>

<div class=blockindent>&nbsp; &#9679; &nbsp; The face center is simply the average of the face vertices</div><br>

<!-- Page 77 -->
<h3>Quickhull 3D: Epsilon</h3>
<div class="caption"><img src="img/68.png" width=500></div>
Также как и в двухмерном варианте алгоритма, нужно значение "эпсилон" для определения толщины плоских плоскостей и мы просто расширяем нашу формулу до 3D!
As in 2D we need an epsilon to define the thickness of flat planes and we just expand our formula to 3D!<br><br>

<!-- Page 78 -->
<h3>Quickhull 3D: Соединение копланарных граней</h3>
<div class="caption"><img src="img/69.png" width=600><br>Копланарные грани F1 (с вершинами V1, V2, V3) и F2 (с вершинами V5, V3, V2) объединяются в одну грань F12 (с вершинами V1, V2, V5, V3)</div><br>
При обнаружении невыпуклого ребра, объединяем две смежные грани.
<div class=blockindent>&nbsp; &#9679; &nbsp; При этом добавляется ещё один шаг в наш пошаговый (итерационный) цикл.</div>
<div class=blockindent>&nbsp; &#9679; &nbsp; Предположим, что грани face1 и face2 в предыдущем примере были невыпуклыми.</div>

<div class=blockindent>&nbsp; &#9679; &nbsp; Теперь объединим face1 и face2 в новую полигональную грань, заменив исходные грани F1 и F2.
We would now merge face1 and face2 into a new polygonal face replacing the original faces F1 and F2</div>

<div class=blockindent>&nbsp; &#9679; &nbsp; Как уже упоминалось в начале лекции, мы не ограничиваемся треугольными гранями.
As mentioned in the beginning we are not restricting ourselves to triangle faces</div>

<!-- Page 79 -->
<h3>Quickhull 3D: Проблемная оболочка</h3>
<div class="caption"><img src="img/70.png" width=400><br>Ситуация: грани F1 и F3 видимы из новой точки P, а F2 нет!</div><br>
Давайте теперь рассмотрим пример из оригинальной статьи Quickhull:
<div class=blockindent>&nbsp; &#9679; &nbsp; Основная тема следующих слайдов реально показать что произойдет, если не объединять грани и как можно столкнуться с кучей геометрических и топологических проблем!</div>
<div class=blockindent>&nbsp; &#9679; &nbsp; Все, что нужно понять здесь и сейчас, - объединение граней в самом деле критическая операция!</div><br>
Ситуация выглядит примерно так: грани <tt>F1</tt> и <tt>F3</tt> видимы из новой точки <tt>P</tt>, в то время как грань <tt>F2</tt> не видна!
<div class=blockindent>&nbsp; &#9679; &nbsp; Фигуру в этом примере можно рассматривать как простой тетраэдр - четырехгранник.</div>

<div class=blockindent>&nbsp; &#9679; &nbsp; Передняя грань находится в плоскости экрана и не слита в одну большую грань треугольника, но фактически похожа на веер из трех граней.
The front face is in the screen plane and was  not  merged into one big triangle face, but is essentially a fan of three faces</div>

<div class=blockindent>&nbsp; &#9679; &nbsp; Нам кажется, что грани F1 – F3 копланарны. It appears to us as if faces F1 –  F3 are coplanar</div>

<div class=blockindent>&nbsp; &#9679; &nbsp; Но плохая новость в том, что копланарность существует только в идеальном мире, а не в мире чисел с ограничениями по точности!
But the bad news is that coplanar only exists in an ideal world, but not in the world of limited precision numbers!</div>


<!-- Page 80 -->
<div class="caption"><img src="img/71.png" width=400><br>Ситуация: грани F1 и F3 видимы из новой точки P, а F2 нет!</div><br>
Что на самом деле происходит (и я несколько преувеличиваю здесь ситуацию) заключается в том, что:
What really happens is (and I am exaggerating the situation here a little bit) is that:

<div class=blockindent>&nbsp; &#9679; &nbsp; Две центральные точки фактически сдвинуты внутрь. The two center points are actually moved inside</div>

<div class=blockindent>&nbsp; &#9679; &nbsp; А ребра между F1 и F2, а также F2 и F3 являются вогнутыми.
And the edges between F1 and F2 and also F2 and F3 are concave</div>

<!-- Page 81 -->
<div class="caption"><img src="img/72.png" width=700></div>
Now let’s rotate the tetrahedron and assume we are now looking from behind point P and at the bottom :

<div class=blockindent>&nbsp; &#9679; &nbsp; You can hopefully see the new point and the bottom edges of the three faces</div>

<div class=blockindent>&nbsp; &#9679; &nbsp; Due to the non-convexity the new point gets kind of locked behind the three planes that leads to this weird situation</div>

<!-- Page 82 -->
<h3>Урезанный горизонт</h3>
<div class="caption"><img src="img/73.png" width=400><br>The depth-first search will yield the horizon in CCW order!</div><br>
We continue and build now the horizon as we learned earlier using the DFS

<div class=blockindent>&nbsp; &#9679; &nbsp; The results in five horizon edges a, b, c, d, and e as sketched on the slide</div>

<!-- Page 83 -->
<h3>Новые грани</h3>
<div class="caption"><img src="img/74.png" width=400></div>
Next we replace F1 and F3 with 5  new faces for each edge a−e


<div class=blockindent>&nbsp; &#9679; &nbsp; Since the outcome of the operation is  pretty interesting let’s look at each of the new faces individually</div>

<h3>Грань A</h3>
<div class="caption"><img src="img/75.png" width=400></div>
Создаем грань для ребра <tt>a</tt>.
<div class=blockindent>&nbsp; &#9679; &nbsp; Обратите внимание, что эта грань частично перекрывает грань face2, которая ещё находится на оболочке.</div>
<h3>Грань B</h3>
<div class="caption"><img src="img/76.png" width=400></div>
Создаем грань для ребра <tt>b</tt>.
<div class=blockindent>&nbsp; &#9679; &nbsp; Обратите внимание, что эта грань с перевернутой ориентацией (по часовой стрелке), а также разделяет и ребро с F<sub>a</sub>.</div>
<h3>Грань C</h3>
<div class="caption"><img src="img/77.png" width=400></div>
Создаем грань для ребра <tt>c</tt>.
<div class=blockindent>&nbsp; &#9679; &nbsp; Ура, здесь ничего плохого нет.</div>
<h3>Грань D</h3>
<div class="caption"><img src="img/78.png" width=400></div>
Создаем грань для ребра <tt>d</tt>.
<div class=blockindent>&nbsp; &#9679; &nbsp; Обратите внимание, эта грань снова перевернута (по часовой стрелке, как и F<sub>b</sub>) и также имеет общее ребро с гранями F<sub>a</sub> и F<sub>b</sub>.</div>
<h3>Грань E</h3>
<div class="caption"><img src="img/79.png" width=400></div>
Создаем грань для ребра <tt>e</tt>.
<div class=blockindent>&nbsp; &#9679; &nbsp; Вот теперь имеется уже четыре грани, которые совместно используют одну и ту же грань, а также частично перекрывающие друг друга.</div>

<!-- Page 89 -->
<h3>Грань 2</h3>
<div class="caption"><img src="img/80.png" width=500></div>
<div class=blockindent>&nbsp; &#9679; &nbsp; Из-за погрешности вычислений грань <tt>face2</tt> до сих пор определяется как видимая из точки <b>P</b> и будет оставаться на оболочке.</div>

<!-- Page 90 -->
<h3>Ошибки</h3>
Получилось так, что было допущено несколько серьезных ошибок, перед добавлением новой точки наша оболочка была в ненормальном состоянии.<br>
В результате новые грани нарушают ряд геометрических и топологических инвариантов:
<div class=blockindent>&nbsp; &#9679; &nbsp; Две грани (F<sub>b</sub> и F<sub>d</sub>) перевернуты вверх ногами (то есть, нормали этих граней направлены вовнутрь).</div>

<div class=blockindent>&nbsp; &#9679; &nbsp; У четырех граней (F<sub>a</sub>, F<sub>b</sub>, F<sub>d</sub>, F<sub>e</sub>,) имеется одно и тоже общее ребро (что делает их частично или полностью перекрывающими друг друга).</div>
Можно представить себе, что исправление этих ошибок будет довольно сложным.<br>
Хорошей новостью будет то, что при правильном соединении граней при построении оболочки я не сталкивался ни с одной из описанных проблем.<br>
Надеюсь вы увидели, как важно для надежной реализации алгоритма придерживаться правильного построения оболочки.<br><br>

<!-- Page 91 -->
<h3>Half-Edge mesh</h3>
Пока еще не было разговора о структуре данных для выпуклых многогранников. Поэтому, перед более подробным изучением объединения граней, давайте сначала рассмотрим возможную структуру данных:
<div class=blockindent>&nbsp; &#9679; &nbsp; Понятно, что существует много способов описания выпуклого многогранника.</div>
<div class=blockindent>&nbsp; &#9679; &nbsp; Обычной структурой данных является так называемая полуреберная структура данных, которая представляет собой сетку, ориентированную на ребра.</div>
<div class=blockindent>&nbsp; &#9679; &nbsp; Полуреберная структура данных упрощает итерацию (перебор) ребер грани и обращение к смежным граням.</div>
<div class="caption"><img src="img/81.png" width=500></div>
Для каждой грани сохраняется:
For each face we store:

<div class=blockindent>&nbsp; &#9679; &nbsp; A half-edge that defines the entry into a circular list around the face</div>

Для каждого ребра сохраняется:
For each edge we store:

<div class=blockindent>&nbsp; &#9679; &nbsp; The previous and next edge that build the circular list around the face</div>

<div class=blockindent>&nbsp; &#9679; &nbsp; Двойное ребро, для перехода к соседней грани.
A twin edge to cross over to the adjacent face</div>

<div class=blockindent>&nbsp; &#9679; &nbsp; И хвостовая вершина ребра.
And the tail vertex of the edge</div>

<div class=blockindent>&nbsp; &#9679; &nbsp; Обратите внимание на то, что нам не нужно хранить головную вершину, поскольку она просто-напросто хвостовая вершина двойного ребра.
Note that we don’t need to store the head vertex since it is simple the tail vertex of the twin edge</div><br>

<!-- Page 92 -->
<h3>Объединение граней</h3>
<div class="caption"><img src="img/82.png" width=800></div>
We learned that face merging is the essential operation to maintain a healthy hull.

<div class=blockindent>&nbsp; &#9679; &nbsp; Here is an example how to merge two faces using the half-edge data structure.</div>

<div class=blockindent>&nbsp; &#9679; &nbsp; The situation is that we are about to merge the left into the right face</div>

<div class=blockindent>&nbsp; &#9679; &nbsp; This means that edge e and its twin will go away and also the left face</div>

<!-- Page 93 -->
<div class="caption"><img src="img/83.png" width=800></div>
First we make sure that the absorbing right face does not reference the edge we are about to delete (e.g. we use edge->prev here)

<!-- Page 94 -->
<div class="caption"><img src="img/84.png" width=800></div>
Next we must make sure that all edges of the absorbed left face will now reference the right face as their owner

<!-- Page 95 -->
<div class="caption"><img src="img/85.png" width=800></div>
Finally we need to connect the incoming and outgoing edges

<div class=blockindent>&nbsp; &#9679; &nbsp; Also note that we can access all necessary data for the merge operation just from the shared edge between the two adjacent faces we are about to merge</div><br>

<!-- Page 96 -->
The result of two of merged faces is a polygonal face with its vertices  not quite coplanar

<div class=blockindent>&nbsp; &#9679; &nbsp; Remember that we are in the world of limited precision numbers</div>

<div class=blockindent>&nbsp; &#9679; &nbsp; The Newell algorithm builds a best fit plane in the least square sense which minimizes the distance of the vertices</div>

<!-- Page 97 -->
<div class="caption"><img src="img/86.png" width=300></div>
I added some formulas for completeness and convenience, but going into detail here would get us off topic.

<div class=blockindent>&nbsp; &#9679; &nbsp; Both Gino’s and Christer’s books cover Newell planes and I also added some additional links in the references</div><br>

<!-- Page 98 --><img src="img/87.png" width=200 align=right>
<h3>Топологические инварианты</h3>

Now let’s look at one important topological invariant of a convex hull.

<div class=blockindent>&nbsp; &#9679; &nbsp; The most important one for us is that each vertex must have at least three adjacent faces</div>

<div class=blockindent>&nbsp; &#9679; &nbsp; We call a vertex redundant if it does not satisfy this invariant</div>


Of course there are other topological invariants, like:

<div class=blockindent>&nbsp; &#9679; &nbsp; Each face must have at least three neighbors</div>

<div class=blockindent>&nbsp; &#9679; &nbsp; Each edge is shared exactly between two faces</div>

<div class=blockindent>&nbsp; &#9679; &nbsp; Each face of a convex polyhedron must be a convex polygon</div>

<div class=blockindent>&nbsp; &#9679; &nbsp; But as is turns out we don’t need to deal with those directly</div>


<!-- Page 99 -->
<h3>Исправление топологических ошибок</h3>
<div class="caption"><img src="img/88.png" width=600></div>
When merging faces we might violate topological invariants and need to fix those:

Consider the merge sequence in the above picture and how it can lead to topological errors:

<div class=blockindent>&nbsp; &#9679; &nbsp; We merge face1 into face3</div>

This creates a couple of problems:

<div class=blockindent>&nbsp; &#9679; &nbsp; Vertex v has now only two adjacent faces and has become redundant</div>

<div class=blockindent>&nbsp; &#9679; &nbsp; Face2 has only two neighbors</div>

<div class=blockindent>&nbsp; &#9679; &nbsp; Face13 is not convex</div>


<!-- Page 100 -->
<div class="caption"><img src="img/89.png" width=600></div>
We detect this error by checking the adjacent faces of the in- and outgoing edges ->

Both edges point to face2

<div class=blockindent>&nbsp; &#9679; &nbsp; Since face2 is a triangle we will not connect the in- and outgoing edge, but use the non-shared edge instead</div>

<div class=blockindent>&nbsp; &#9679; &nbsp; Note that face2 is redundant as well since all vertices are contained in face13 and can be deleted</div>

<div class=blockindent>&nbsp; &#9679; &nbsp; Vertex v has also become obsolete and will be deleted as well</div>

The trick here is that when we merge two faces we check for this error and fix it immediately!

<!-- Page 101 -->
<div class="caption"><img src="img/90.png" width=600></div>
Let’s look at the previous example again.

Consider now the slightly different merge sequence:

<div class=blockindent>&nbsp; &#9679; &nbsp; We now merge face2 into face1</div>

Again:

<div class=blockindent>&nbsp; &#9679; &nbsp; Vertex v has now only two adjacent faces and has become redundant</div>

<div class=blockindent>&nbsp; &#9679; &nbsp; Besides this I don’t notice any other problem in this case</div>

<!-- Page 102 -->
<div class="caption"><img src="img/91.png" width=600></div>
We detect this error again by checking the adjacent faces of the in- and outgoing

edges -> Both edges point to face3 here

<div class=blockindent>&nbsp; &#9679; &nbsp; Since face3 has now more than three vertices we cannot apply the same fixing strategy as before</div>

<div class=blockindent>&nbsp; &#9679; &nbsp; Instead we simply extend the incoming edge to the next vertex and delete the outgoing edge</div>

<div class=blockindent>&nbsp; &#9679; &nbsp; Again vertex v has become obsolete and should be deleted as well</div>

Again when we merge faces we check for this error and fix it immediately!

<!-- Page 103 -->
<h3>Большие циклы объединения</h3>
<div class="caption"><img src="img/92.png" width=800></div>
Another problem you will encounter when merging faces is that you might a large number of new faces that should be all merged:

<div class=blockindent>&nbsp; &#9679; &nbsp; Let’s call this a merge cycle</div>

Imagine we are building the convex of hull of a cylinder and we are about to add the final vertex of the top face:

<div class=blockindent>&nbsp; &#9679; &nbsp; This vertex of course presents itself as in the same plane as the other vertices.</div>

<div class=blockindent>&nbsp; &#9679; &nbsp; In this situation we create many new faces which are roughly coplanar and need to be merged</div>

<div class=blockindent>&nbsp; &#9679; &nbsp; Ideally we would like to merge all new faces into one face as shown on the right hand side</div>

<!-- Page 104 -->
<div class="caption"><img src="img/93.png" width=400></div>
The problem is now that we practically merge one face after the other:

<div class=blockindent>&nbsp; &#9679; &nbsp; Whenever we merge two faces we rebuild the face plane.</div>

<div class=blockindent>&nbsp; &#9679; &nbsp; Rebuilding the face can jiggle the plane and an edge between two faces can become temporarily convex and prevent us from merging the whole cycle</div>

<div class=blockindent>&nbsp; &#9679; &nbsp; In the worst case this can introduce concave faces which are now NOT merged properly</div>



Here are some ideas how to address this:

<div class=blockindent>&nbsp; &#9679; &nbsp; The faces with the largest area should be the most stable w.r.t. the orientation of the face plane. So merging into the largest faces first reduces jiggle. Think of merging the little sister into the big daddy</div>

<div class=blockindent>&nbsp; &#9679; &nbsp; You can also introduce an absolute tolerance to increase your merge radius and make your merge cycle less sensitive for these situations.</div>

<div class=blockindent>&nbsp; &#9679; &nbsp; This is basically how I handle this problem at the moment since for physics we want as large faces as possible for stability reasons and do not aim for the tightest hull.</div>

<div class=blockindent>&nbsp; &#9679; &nbsp; If you are working with collision margins it is probably a good idea to make this absolute tolerance a small percentage of that margin</div>


<!-- Page 105 -->
<div class="caption"><img src="img/94.png" width=600><br>face plane - плоскость грани</div><br>
Еще одна идея для решения этой проблемы - при объединении граней вообще НЕ перестраивать плоскости граней:
Another idea to deal with this problem is to NOT rebuild the face planes at all when merging to faces:

<div class=blockindent>&nbsp; &#9679; &nbsp; For both faces you have your best fit plane and the vertices (which I tried to sketch on the slide)</div>

<div class=blockindent>&nbsp; &#9679; &nbsp; We can now compute the absolute distance of the right face’s vertices to the left face’s plane and vice versa</div>

<div class=blockindent>&nbsp; &#9679; &nbsp; Then we simply keep the face plane that minimizes the distance instead of rebuilding it</div>

<!-- Page 106 -->
Let’s close this part how we could use face merging to deal with defect hulls:

<div class=blockindent>&nbsp; &#9679; &nbsp; At each iteration the basic assumption is to start with a healthy hull</div>

<div class=blockindent>&nbsp; &#9679; &nbsp; When adding the vertex we need to inspect all new faces for possible defects at their edges between each other and at the horizon</div>

<div class=blockindent>&nbsp; &#9679; &nbsp; These are the weak spots where might have introduced new errors</div>

<div class=blockindent>&nbsp; &#9679; &nbsp; An easy strategy is to iterate all new faces and repair each edge one by one</div>

<!-- Page 107 -->
This closes the theory and in the remainder of this talk I like to share some quick tips about a possible implementation

<!-- Page 108 -->
The major performance pitfall is bad memory management of the half-edge data structure:

<div class=blockindent>&nbsp; &#9679; &nbsp; The convex hull for N vertices is bounded</div>

<div class=blockindent>&nbsp; &#9679; &nbsp; Worst case is that all input vertices are on the hull:</div>

<div class=blockindent>&nbsp; &#9679; &nbsp; The number of vertices is then at most V = N</div>

<div class=blockindent>&nbsp; &#9679; &nbsp; The number of edges is then at most E = 3N – 6</div>

<div class=blockindent>&nbsp; &#9679; &nbsp; The number of faces is then at most F = 2N – 4</div>

<div class=blockindent>&nbsp; &#9679; &nbsp; Test with Euler’s formula: V –  E + F = 2</div>



In our implementation we can pre-allocate one buffer for vertices, half-edges, and faces and manage this buffer in a free list

<div class=blockindent>&nbsp; &#9679; &nbsp; Ideally we will just have one big allocation per hull construction!</div>

<div class=blockindent>&nbsp; &#9679; &nbsp; This becomes especially important if you plan to compute convex hulls at runtime (e.g. for destruction)</div>



Here are some practical details:

<div class=blockindent>&nbsp; &#9679; &nbsp; Don’t forget that you need to allocate half-edges (which is twice the number of edges)</div>

<div class=blockindent>&nbsp; &#9679; &nbsp; We also need to account for temporary allocations (e.g. horizon faces)</div>

<div class=blockindent>&nbsp; &#9679; &nbsp; In practice I just double the buffer size</div>

<!-- Page 109 -->
<h3>Реализация: полуреберная сетка</h3>
<pre>struct qhVertex
{
  qhVertex * Prev;
  qhVertex * Next;<br>
  // Optional (дополнительно)
  qhHalfEdge* Edge;<br>
  qhVector3 Position;
};</pre>
Let’s start with the vertex structure.

<div class=blockindent>&nbsp; &#9679; &nbsp; I am using an intrusive list to store the vertices</div>

<div class=blockindent>&nbsp; &#9679; &nbsp; The vertices are either on the hull or in a conflict list</div>

<div class=blockindent>&nbsp; &#9679; &nbsp; So obviously we have to include the list pointers here.</div>

<div class=blockindent>&nbsp; &#9679; &nbsp; We can optionally also store an edge leaving the vertex.</div>

<div class=blockindent>&nbsp; &#9679; &nbsp; This is not needed for constructing the hull, but it can be useful for post-processing if you like e.g. to iterate all adjacent faces of the vertex</div>

<div class=blockindent>&nbsp; &#9679; &nbsp; Of course we also to need store the position of a vertex</div>

<!-- Page 110 -->
<pre>struct qhHalfEdge
{
  qhVertex* Tail;<br>
  qhHalfEdge* Prev;
  qhHalfEdge* Next;
  qhHalfEdge* Twin;<br>
  qhFace* Face;
};</pre>
Now let’s have a quick look how we can potentially implement a half-edge:

<div class=blockindent>&nbsp; &#9679; &nbsp; As we would expect this definition maps pretty directly to a possible data structure</div>

<div class=blockindent>&nbsp; &#9679; &nbsp; We store a pointer to the tail vertex of the edge</div>

<div class=blockindent>&nbsp; &#9679; &nbsp; The half-edges build a circular list around the face so we also need to store the list pointers here</div>

<div class=blockindent>&nbsp; &#9679; &nbsp; And of course we also store the twin edge to cross over to the adjacent face</div>

<div class=blockindent>&nbsp; &#9679; &nbsp; Finally we also keep a reference to the parent face of the edge</div>


<!-- Page 111 -->
<pre>struct qhFace
{
  qhFace* Prev;
  qhFace* Next;<br>
  qhHalfEdge* Edge;
  qhList&lt; qhVertex > ConflictList;
};</pre>
Finally the face structure:

<div class=blockindent>&nbsp; &#9679; &nbsp; I am also using an intrusive list here, so we have to include the list pointers again</div>

<div class=blockindent>&nbsp; &#9679; &nbsp; And of course there is a pointer to the first edge starting the circular list around the face</div>

<div class=blockindent>&nbsp; &#9679; &nbsp; Finally it is possibly a good idea to store our conflict list here as well</div>


<!-- Page 112 -->
<h3>Реализация: построение (construction)</h3>
<pre>void qhConvex::Construct( const qhArray&lt; qhVector3 >& Vertices )
{
  if ( !BuildlnitialHull( Vertices) )
    return;<br>
  qhVertex* Vertex = NextConflictVertex();
  while ( Vertex != NULL )
  {
    AddVertexToHull( Vertex );
    Vertex = NextConflictVertex();
  }
};</pre>
Finally some high-level code examples to give you an idea of a possible implementation:

<div class=blockindent>&nbsp; &#9679; &nbsp; Assume we have some qhConvex class to store the hull after construction</div>

<div class=blockindent>&nbsp; &#9679; &nbsp; This snippet shows the top level construction function</div>

Explain a bit…

<!-- Page 113 -->
<h3>Реализация: повторение (iteration)</h3>
<pre>void qhConvex::AddVertex( const qhVertex* Vertex )
{
  qhArray&lt; qhHalfEdge* > Horizon;
  BuildHorizion( Horizon );<br>
  qhArray&lt; qhFace* > NewFaces;
  BuildNewFaces( NewFaces, Horizon );
  MergeFaces( NewFaces );<br>
  ResolveOrphans( NewFaces );
};</pre>
The code snippets shows the iterative AddVertex() function

<div class=blockindent>&nbsp; &#9679; &nbsp; We add new points until our conflict lists are empty</div>

Explain a bit…

<!-- Page 114 -->
So you want to implement Qhull yourself and I talked now for nearly an hour and there is no code!

<div class=blockindent>&nbsp; &#9679; &nbsp; Luckily there is a beautiful open-source implementation in JAVA which you can use to start</div>

<div class=blockindent>&nbsp; &#9679; &nbsp; I also recommend looking at the original Qhull implementation which is not only a great implementation, but also full of gems of computational geometry!!!</div>

This closes the talk and hopefully my presentation will help you to understand and implement a robust convex hull builder!

Thank you!<br><br>

<h3>Ссылки</h3>
Описание алгоритма Quickhull:
<div class=blockindent><a href="http://dpd.cs.princeton.edu/Papers/BarberDobkinHuhdanpaa.pdf" target="_blank">C. Barber/D. Dobkin: "The Quickhull Algorithm for Convex Hulls"</a><br>
R. Seidel: "Small Dimensional Linear Programming and Convex Hulls Made Easy"<br>
J. Smith: "Quickhull 3D"</div>
Книги:
<div class=blockindent>G. v. d. Bergen: "Collision Detection in Interactive 3D Environments"<br>
C. Ericson: "Real-time Collision Detection"<br>
J. O'Rourke: "Computational Geometry in C"<br>
M. de Berg: "Computational Geometry"<br>
E. Langetepe: "Geometric Data Structures for Computer Graphics"</div>
Публикации на смежные темы:
<div class=blockindent>G. Rhodes: "Computational Geometry" (Half-Edge Mesh)<br>
M. McGuire: "The Half-Edge Data Structure" (Half-Edge Mesh)<br>
D. Gordon: "Computing the Plane Equation of a Polygon" (Newell Plane)<br>
E. Catto: "A Troublesome Triangle" (Newell Plane)<br>
S. Melax: "Interaction with 3D Geometry" (StanHull)</div>
Статьи о вычислениях с плавающей запятой:
<div class=blockindent><a href="http://randomascii.wordpress.com/categorv/floating-point/" target="_blank">B. Dawson: http://randomascii.wordpress.com/categorv/floating-point/</a><br>
<a href="http://realtimecollisiondetection.net/pubs/Tolerances/" target="_blank">C. Ericson: http://realtimecollisiondetection.net/pubs/Tolerances/</a></div>
<br><br>

<!-- Page 115 -->
Before I close I like to thank a bunch of people!
<div class=blockindent>&nbsp; &#9679; &nbsp; Thanks to Valve for giving me permission to present to you today</div>
<div class=blockindent>&nbsp; &#9679; &nbsp; Thanks to Paul, Steve, Jeff and Anoush for spending time and rehearse this presentation with me</div>
<div class=blockindent>&nbsp; &#9679; &nbsp; Thanks to Randy for reading the presentation several times at an early stage and providing valuable feedback</div>
<div class=blockindent>&nbsp; &#9679; &nbsp; Special thanks to Bruce Dawson for helping with the numerical problems in Quickhull and also providing all kinds of other valuable feedback</div>
<div class=blockindent>&nbsp; &#9679; &nbsp; Special thanks to John Lloyd for sharing his beautiful JAVA Quickhull implementation and making it open source</div>
If you liked this talk and if you want to see more cool Valve presentations please visit out website!

<br><br>
</body></html>
