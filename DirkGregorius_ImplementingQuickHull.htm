<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
<title>DirkGregorius_ImplementingQuickHull</title>
<meta http-equiv="content-type" content="text/html; charset=utf-8">
<link rel="stylesheet" type="text/css" href="1.css">
<script type="text/javascript" src="1.js"></script>
</head>
<body>
<a href="https://www.gamedev.net/profile/30524-dirk-gregorius/?tab=activity"><img src="img/Dirk_Gregorius.png" width=150 border=0 align="left" alt="Dirk Gregorius" style="margin-top:-20px;"></a>
<div style="color:#000080; margin-left:220px;"><a href="https://www.gamedev.net/profile/30524-dirk-gregorius/?tab=activity">Dirk Gregorius</a></div>

<h1 style="margin-top:20px; margin-left:200px; margin-bottom:40px;">Реализация быстрого алгоритма выпуклой оболочки<br>
<span style="font-size:70%; margin-left:20px;">Implementing&nbsp;QuickHull</span></h1><br><br>
Добрый день! Меня зовут Дирк, и я инженер-программист в Valve.<br><br>
Некоторые из вас возможно заметили, что я изменил заголовок своей лекции на: "Реализация алгоритма выпуклой оболочки".<br>
Когда я пересказывал эту лекция в Valve, одним из вопросов был: "Почему презентация об алгоритме выпуклой оболочки? Разве это не хорошо понимаемый алгоритм?"<br>
На мой взгляд это отчасти верно. Можно найти несколько презентаций об основах теории выпуклой оболочки и аналитических статей некоторой сложности, но вряд ли
это все имело отношение к реализации данного алгоритма.
Особенно в производственной среде, где приходится иметь дело со всеми видами недостаточно определенной входной геометрией!
Так что, эта лекция будет охватывать, конечно же, основную теорию Quickhull, но также потратим много времени на изучение проблем, с которыми вы можете столкнуться при реализации Quickhull, и способах их решения.<br><br>

<h2>План лекции</h2>
Вначале хотелось бы быстро изложить план лекции:
<div class=blockindent>&nbsp; &#9679; &nbsp; После короткого вступления сначала будет разговор об алгоритме выпуклой оболочки (Quickhull) в двумерном пространстве.</div>
<div class=blockindent>&nbsp; &#9679; &nbsp; Затем продолжим описание с геометрическими постоянными (инвариантами), которых нужно придерживаться при построении оболочки, во избежание проблем с вычислениями.</div>
<div class=blockindent>&nbsp; &#9679; &nbsp; После знакомства с двумерным вариантом, тут же погружаемся в трехмерную версию быстрой оболочки.</div>
<div class=blockindent>&nbsp; &#9679; &nbsp; Затем исследуем геометрические и топологические инварианты при построении оболочки в трехмерном пространстве и
We then investigate geometrical and topological invariants while constructing the hull in 3D and close with some implementation details.</div><br>

<h1 class=head1>Вступление</h1>
<h3>Выпуклость</h3>
Прежде чем начать, давайте выясним, что такое выпуклая оболочка и рассмотрим пример:
<div class=blockindent>&nbsp; &#9679; &nbsp; Фигура называется выпуклой, если для любых двух точек, которые находятся <b>внутри</b> фигуры, линия между этими двумя точками также находится внутри.</div>
<div class=blockindent>&nbsp; &#9679; &nbsp; Если посмотреть на случай с вогнутой фигурой, то легко можно найти внутри фигуры две точки, линия между которыми выходит за контур фигуры и затем снова входит в неё.</div>
<table width=90%><tr><td width=50%><div class="caption"><img src="img/1a.png" width=250><br>Выпуклая фигура (convex)</div></td>
<td width=50%><div class="caption"><img src="img/1b.png" width=250><br>Вогнутая фигура (concave)</div></td></tr></table><br><br>

<h3>Выпуклые оболочки</h3>
Что такое выпуклая оболочка (convex hull)?<br>
Задав набор из энного числа входных точек можно определить, что можно называть выпуклой оболочкой:
<div class=blockindent>&nbsp; &#9679; &nbsp; Официальное определение: выпуклая оболочка это наименьший выпуклый набор, содержащий все входные точки.</div>
<div class=blockindent>&nbsp; &#9679; &nbsp; По простому: Если все точки представить в виде гвоздей, вбитых в деревянную дощечку, то выпуклая оболочка будет резинкой, натянутой вокруг внешних гвоздей.</div>
<div class="caption"><img src="img/2.png" width=250><br>Набор точек в двумерном пространстве и его выпуклая оболочка</div><br>
<b>Это означает, что в двумерном пространстве оболочкой является многоугольник (полигон), определяемый вершинами и ребрами!</b><br><br>

Также хочется показать трехмерную выпуклую оболочку вокруг хорошо известного объекта - чайника Юта (Utah Teapot).
<div class=blockindent>&nbsp; &#9679; &nbsp; В двумерном пространстве для получения некоего понимания о выпуклой оболочке в качестве аналога использовалось кольцо резинки.</div>
<div class=blockindent>&nbsp; &#9679; &nbsp; В трехмерном пространстве выпуклую оболочку можно рассматривать как упаковку объекта плотно обтягивающей пленкой.</div>
<div class="caption"><img src="img/3.png" width=600></div><br>
<b>В трехмерном пространстве оболочкой является многогранник, определяемый вершинами, ребрами и многоугольными (полигональными) гранями! Обратите внимание, что мы не собираемся ограничиваться только треугольными гранями!</b><br><br>

<h4>Использование выпуклых оболочек для обнаружения столкновений</h4>
Почему следует использовать выпуклые оболочки для обнаружения столкновений в играх?
<div class=blockindent>&nbsp; &#9679; &nbsp; Динамические объекты в играх используют приближение к простым формам для обнаружения столкновений поскольку использование отображения геометрического элемента <b>не будет</b> эффективным с точки зрения производительности.</div>
<div class=blockindent>&nbsp; &#9679; &nbsp; Выпуклые оболочки - хороший кандидат на замену, поскольку они могут достаточно хорошо соответствовать даже сложному геометрическому элементу.</div>
<div class=blockindent>&nbsp; &#9679; &nbsp; Кроме того, обнаружение столкновений для выпуклых многогранников хорошо и надежно определяется. Вспомните о <a href="https://ru.wikipedia.org/wiki/%D0%90%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC_%D0%93%D0%B8%D0%BB%D0%B1%D0%B5%D1%80%D1%82%D0%B0_%E2%80%94_%D0%94%D0%B6%D0%BE%D0%BD%D1%81%D0%BE%D0%BD%D0%B0_%E2%80%94_%D0%9A%D1%91%D1%80%D1%82%D0%B8" onmouseover="show('GJK - сокращ. от англ. слов Gilbert—Johnson—Keerthi algorithm<br>(алгоритм Гилберта—Джонсона—Кёрти) — алгоритм для<br>определения минимального расстояния между двумя<br>выпуклыми множествами (объектами)')" onmouseout="hide()">GJK</a> и
<a href="https://ru.wikipedia.org/wiki/%D0%A2%D0%B5%D0%BE%D1%80%D0%B5%D0%BC%D0%B0_%D0%BE%D0%B1_%D0%BE%D0%BF%D0%BE%D1%80%D0%BD%D0%BE%D0%B9_%D0%B3%D0%B8%D0%BF%D0%B5%D1%80%D0%BF%D0%BB%D0%BE%D1%81%D0%BA%D0%BE%D1%81%D1%82%D0%B8" onmouseover="show('SAT - сокращ. от англ. слов Separating Axis Theorem<br>(теорема разделяющей оси) для двух выпуклых объектов<br>можно сформулировать так: два выпуклых объекта<br>пересекаются тогда и только тогда, когда существует<br>плоскость (для двумерного случая - прямая), такая,<br>что одна геометрия лежит по одну её сторону, а другая<br>- по другую')" onmouseout="hide()">SAT</a>, которые мы обсуждали уже здесь в предыдущих руководствах.
<!-- http://www.dyn4j.org/2010/01/sat/ --></div><br>

<h4>Использование выпуклых оболочек в игре</h4>
<div class="caption"><img src="img/4.png" width=600></div><br>
Прежде чем начать, хочется показать два видеоролика, чтобы было представление о том, как выпуклые оболочки используются в играх:
<div class=blockindent>&nbsp; &#9679; &nbsp; Показать видеоролик о выпуклых оболочках в игре.</div>
<div class=blockindent>&nbsp; &#9679; &nbsp; Показать, как физический движок рассматривает игру.</div>

Sergiy will show you how to implement awesome physics visualization right after this talk!<br><br>
Надеюсь что видеоролики дали общее представление проблемы, которую мы попытаемся здесь решить.<br><br>


Когда я начал присматриваться к построению выпуклых оболочек, то быстро наткнулся на алгоритм под названием Quickhull:
<div class=blockindent>&nbsp; &#9679; &nbsp; Quickhull был выпущен в 1995 году Barber и Dobkin.</div>
<div class=blockindent>&nbsp; &#9679; &nbsp; По существу это пошаговый (итеративный) алгоритм, который добавляет отдельные точки (по одной за раз) к промежуточной оболочке.</div>
<div class=blockindent>&nbsp; &#9679; &nbsp; При реализации алгоритма для построения выпуклых оболочек приходится иметь дело с входной геометрией, которая сталкивается с ограничением точности вычислений с плавающей запятой.</div>
<div class=blockindent>&nbsp; &#9679; &nbsp; Для решения этих проблем Quickhull использует так называемые "толстые" плоскости и объединение граней.</div>
<div class=blockindent>&nbsp; &#9679; &nbsp; В результате работы алгоритма появляется набор "толстых" граней, которые ограничивают конкретную выпуклую оболочку.</div>
В последующей части лекции попробуем подробно разъяснить, что это значит!<br><br>

<!-- Page 9 -->
Знакомство с алгоритмом начнем с его варианта в 2D пространстве.
<div class=blockindent>&nbsp; &#9679; &nbsp; Хотелось бы отметить, что это не "реальный" алгоритм Quickhull для 2D пространства (который существует на самом деле).
Следует думать о нем как о вводной части в трехмерную версию, которая позже будет рассмотрена в этой статье.</div>
<div class=blockindent>&nbsp; &#9679; &nbsp; Лично я считаю, что зачастую полезно сначала рассмотреть все эти вещи в 2D, чтобы ознакомиться с основными идеями и хорошо понять задачу.</div><br><br>

<h1 class=head1>Quickhull 2D</h1>
<h2>Quickhull 2D: Инициализация оболочки</h2>
Предположим, что задан набор точек, и нужно построить выпуклую оболочку с использованием алгоритма Quickhull:
<div class=blockindent>&nbsp; &#9679; &nbsp; Первое, что нужно сделать в Quickhull, - это построить исходную оболочку, из которой можно начать пошагово добавлять точки.</div>
<div class="caption"><img src="img/5.png" width=400></div>
Поиск этой исходной оболочки начнем с определения крайних точек по каждой из осей координат.
<div class=blockindent>&nbsp; &#9679; &nbsp; Если по простому, то это означает, что нужно найти точки с наибольшими и наименьшими значениями координат&nbsp;<tt>x</tt>&nbsp;и&nbsp;<tt>y</tt>.</div>
<div class="caption"><img src="img/6.png" width=580></div>
Из этих четырех точек выбираем пару, в которой точки находятся на самом большом расстоянии друг от друга.
<div class=blockindent>&nbsp; &#9679; &nbsp; В данном примере это будут самая левая и самая правая точки.</div>
<div class="caption"><img src="img/7.png" width=400></div>
Наконец, мы ищем самую дальнюю точку от линии, проведенной через эти две крайние точки
<div class="caption"><img src="img/8.png" width=400></div>
Эти три точки и дадут нашу первоначальную оболочку.
<div class=blockindent>&nbsp; &#9679; &nbsp; Первоначальная оболочка в двумерном пространстве - это просто треугольник.</div>
<div class="caption"><img src="img/9.png" width=400></div><br><br>

<h3>Quickhull 2D: Разделение точек</h3>
Прежде чем начать добавлять новые точки к исходной оболочке, нужно сделать некоторые бухгалтерские работы:
<div class=blockindent>&nbsp; &#9679; &nbsp; Следующим шагом будет разделение оставшихся точек и закрепление каждой точки за ближайшей к ней гранью.</div>
<div class=blockindent>&nbsp; &#9679; &nbsp; Также можно удалить точки внутри исходной оболочки, поскольку они не могут быть на финальном варианте оболочки.</div>
<div class="caption"><img src="img/10.png" width=650><br>
Пояснение к коду на картинке: <tt>CL</tt> - сокращ. англ. слов conflict list - список конфликтов, а <tt>CL(e1)={p1, p2, p3}</tt> означает, что список конфликтов грани <tt>e1</tt> содержит точки <tt>p1</tt>, <tt>p2</tt> и <tt>p3</tt>.</div><br>

Это означает, что каждая грань ведет список точек, которые находятся вне плоскости грани. Эти списки называются «списками конфликтов», поскольку точки могут «видеть» эту грань и следовательно, возможно находятся на финальном варианте оболочки.
Это грамотный способ управления вершинами, поскольку при добавлении к оболочке новой вершины не нужно перебирать все вершины.
Поэтому <a href="https://ru.wikipedia.org/wiki/%D0%92%D1%80%D0%B5%D0%BC%D0%B5%D0%BD%D0%BD%D0%B0%D1%8F_%D1%81%D0%BB%D0%BE%D0%B6%D0%BD%D0%BE%D1%81%D1%82%D1%8C_%D0%B0%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D0%B0" target="_blank">временна&#769;я сложность алгоритма</a>
Quickhull обычно равна <span class="lnk" onmouseover="show('линейно-логарифмическое время,<br>максимально быстрая сортировка<br>сравнением')" onmouseout="hide()"><tt>O(n log n)</tt></span> как в двумерном, так и в трехмерном вариантах!
<div class=warning><b>Предупреждение:</b> Пожалуйста не запутайтесь здесь. Так как алгоритм представлен в двух- и трехмерном вариантах и некоторая терминология совпадает, будем использовать термины «Edge» (ребро, край) и «Face» (грань) как взаимозаменяемые! Это поможет, когда позже в этой лекции перейдем к трехмерному варианту алгоритма!</div>
<div class=note_trans><b>Примечание переводчика:</b> В двумерном пространстве ребром будет простая линия, в отличие от трехмерного пространства, где ребро - это граница между двумя смежными гранями.<br>
Двумерная грань - это часть плоскости между двумя ребрами-линиями, в трехмерном пространстве, грань - это плоскость между ребрами.</div><br><br>


<h3>Quickhull 2D: Поиск следующей вершины</h3>
Следующим шагом будет добавление новой точки к нашему промежуточному варианту оболочки. Перебираем наши списки конфликтов и находим точку <b>p</b> с наибольшим расстоянием от этой оболочки.
<div class=blockindent>&nbsp; &#9679; &nbsp; Давайте назовем эту точку точкой просмотра или обзора.</div>
<div class=blockindent>&nbsp; &#9679; &nbsp; Добавление этой новой точки потребует несколько дополнительных шагов.</div>
<div class="caption"><img src="img/11.png" width=400></div><br>

<h3>Quickhull 2D: Поиск горизонта</h3>
<div class="caption"><img src="img/12.png" width=580></div>
Сначала нам нужно определить все грани, которые видны из недавно добавленной точки, поскольку эти грани могут находиться не на оболочке:

<div class=blockindent>&nbsp; &#9679; &nbsp; Грань является видимой, если эта новая точка находится перед плоскостью грани. A face is visible if the new point is in front of the face plane.</div>

<div class=blockindent>&nbsp; &#9679; &nbsp; Можно воспользоваться простыми проверками плоскости чтобы причислить эту новую точку по отношению к каждой грани!
We can use simple plane tests to classify the new point against each face!</div>

<div class=blockindent>&nbsp; &#9679; &nbsp; Следующий шаг состоит в том, чтобы найти две вершины, соединяющие видимую грань с невидимой.</div>
<div class=blockindent>&nbsp; &#9679; &nbsp; Эти две вершины (<tt>H1</tt> и <tt>H2</tt>) называются горизонтом.</div>
<div class=blockindent>&nbsp; &#9679; &nbsp; Фактически, горизонт является границей между видимой и невидимой частями текущей оболочки, как оно видится из новой точки просмотра.</div><br>

<h3>Quickhull 2D: Добавление точки к оболочке</h3>
После определения двух вершин горизонта, для присоединения новой вершины к оболочке создадим две новые грани от каждой вершины горизонта.
<div class="caption"><img src="img/13.png" width=400></div><br><br>

<!-- Page 19 -->
<h3>Quickhull 2D: Переопределение "осиротевших" точек</h3>
После построения новых граней некоторые старые грани стали ненужными.
<div class=blockindent>&nbsp; &#9679; &nbsp; Прежде чем удалить эти грани, нужно обработать их списки конфликтов, поскольку конфликтные точки в этих списках могут оставаться на финальном варианте оболочки.</div>
<div class=blockindent>&nbsp; &#9679; &nbsp; Обработка заключается в простом переопределении этих "осиротевших" вершин к новым граням.</div>
<div class="caption"><img src="img/14.png" width=600></div><br><br>

<!-- Page 20 -->
<h3>Quickhull 2D: Добавление точки к оболочке</h3>
Наконец, теперь можно удалить все старые грани, которые были видны из новой точки и, следовательно, больше не могут находиться на оболочке.
<div class=blockindent>&nbsp; &#9679; &nbsp; На этом заканчивается данный цикл итераций и далее мы повторяем эти шаги до тех пор, пока не опустеют все списки конфликтов.</div>

<div class=blockindent>&nbsp; &#9679; &nbsp; В нашем примере действие продолжается и захватывается следующая точка просмотра и добавляется к оболочке точно также, как мы только что узнали.
In our example we continue and grab the next eye point and add it to hull as we just learned</div>
<div class="caption"><img src="img/15.png" width=400></div>

<!-- Page 21 -->
И, чтобы найти наш финальный вариант оболочки, делаем это ещё раз ...
<div class="caption"><img src="img/16.png" width=400></div>

<!-- Page 22 -->
<h3>Quickhull 2D:</h3>
И вот, нет больше вершин (все списки конфликтов пусты) и все закончилось!
<div class="caption"><img src="img/17.png" width=400></div><br><br>

<!-- Page 23 -->
Как можно было видеть, все основные идеи были довольно просты для понимания.
<div class=blockindent>&nbsp; &#9679; &nbsp; В 3D варианте алгоритма основные трудности реализации фактически возникают из-за управления списками вершин, ребер, граней и конфликтов.</div>
<div class=blockindent>&nbsp; &#9679; &nbsp; Другая сложность связана с неточностью в вычислениях при классификации точек с использованием проверок плоскости.</div>

<!-- Page 24 -->
До сих пор мы делали вид, что наши математические операции точны.
So far we pretended that our mathematical operations are exact

<div class=blockindent>&nbsp; &#9679; &nbsp; Конечно, это * не * верно в арифметике с плавающей запятой.
Of course this is *not* true in floating point arithmetic.</div>

<div class=blockindent>&nbsp; &#9679; &nbsp; Давайте расследуем, как можно справиться с этими проблемами.
Let’s investigate how we can deal with those problems.</div><br><br>

<!-- Page 25 -->
<h3>Quickhull 2D: Инварианты</h3>
<div class=note_trans><b>Примечание переводчика:</b> Инвариант — это свойство некоторого класса (множества) математических объектов, остающееся неизменным при преобразованиях определённого типа. В топологии — это величина, определённая для каждого узла и одинаковая для эквивалентных узлов.</div>
При построении выпуклой оболочки следует придерживаться геометрических инвариантов.
<div class=blockindent>&nbsp; &#9679; &nbsp; В двумерном варианте алгоритма должна быть обеспечена выпуклость каждой вершины.</div>
<div class=blockindent>&nbsp; &#9679; &nbsp; Это должно быть очевидно, так как в противном случае было бы легко найти прямую между двумя точками внутри оболочки, которая бы выходила из нее и вновь входила, как показано на рисунке в начале статьи.</div>
<div class=blockindent>&nbsp; &#9679; &nbsp; На рисунке это подсказывается пунктирной линией между нормалями, проведенными от оболочки наружу. Как видите, на верхнем рисунке она проходит внутри оболочки (т.е. оболочка выпуклая), а на нижнем - снаружи (оболочка вогнутая).</div>
<div class="caption"><img src="img/18.png" width=600><br>vertex V is convex - вершина V выпуклая, vertex V is concave - вершина V вогнутая</div><br><br>

<!-- Page 26 -->
<h3>Quickhull 2D: Проверка на выпуклость</h3>
Далее нужно определить, что такое выпуклая вершина и как мы можем проверить вершину на выпуклость:<br>
Для каждой вершины:
<div class=blockindent>&nbsp; &#9679; &nbsp; Вначале проверяем, находится ли правая вершина ниже левой грани.</div>
<div class=blockindent>&nbsp; &#9679; &nbsp; Затем проверяем, находится ли левая вершина ниже правой грани.</div>
<div class=blockindent>&nbsp; &#9679; &nbsp; Если обе проверки в итоге дали значение <tt>true</tt> (истина), вершина выпуклая, в противном случае она должна быть либо вогнутая, либо копланарная.</div>
<div class="caption"><img src="img/19.png" width=600><br>left face test - проверка левой грани, right face test - проверка правой грани</div><br><br>

<!-- Page 27 -->
<h3>Quickhull 2D: Надежность вычислений</h3>
Теперь давайте рассмотрим пример, в котором невыпуклые вершины могут стать проблемой:
<div class=blockindent>&nbsp; &#9679; &nbsp; Всякий раз, когда добавляется точка, которая находится на одной линии с существующей гранью (т.е. <a href="https://ru.wikipedia.org/wiki/%D0%9A%D0%BE%D0%BB%D0%BB%D0%B8%D0%BD%D0%B5%D0%B0%D1%80%D0%BD%D0%BE%D1%81%D1%82%D1%8C" target="_blank">колинеарна</a>), некоторые вещи могут стать неопределенными.</div>
<div class=blockindent>&nbsp; &#9679; &nbsp; Небольшое изменение точки <b>P</b> будет определять, останется ли вершина <b>V</b> на оболочке или нет.</div>
<div class=blockindent>&nbsp; &#9679; &nbsp; В идеале хотелось бы иметь более стабильную ситуацию, так чтобы при очень небольших изменениях в пределах некоторого допуска получался бы одинаковый результат.</div>
<div class=blockindent>&nbsp; &#9679; &nbsp; Заметим, что точка <b>P</b> на самом деле не движется, но может оказаться по обе стороны от плоскости <b>просто</b> из-за неточности в вычислениях.</div>
<div class="caption"><img src="img/20.png" width=600><br>
coplanar - копланарный, т.е. находящийся в одной плоскости, concave - вогнутый, convex - выпуклый</div><br><br>

<!-- Page 28 -->
<h3>Quickhull 2D: "Толстые" плоскости</h3>
Общим подходом к решению таких типовых задач является использование так называемых <b>толстых</b> плоскостей.
<div class=blockindent>&nbsp; &#9679; &nbsp; Вместо сравнения непосредственно с нулем мы теперь сравниваем с некоторым значением эпсилон (&#949;).</div>
По-прежнему можно распределять точки при использовании "толстых" плоскостей, как и раньше:
<div class=blockindent>&nbsp; &#9679; &nbsp; Точка находится перед плоскостью, если расстояние между этой точкой и плоскостью больше значения эпсилон.</div>
<div class=blockindent>&nbsp; &#9679; &nbsp; Точка находится позади плоскости, если расстояние между этой точкой и плоскостью меньше отрицательного значения эпсилон.</div>
<div class=blockindent>&nbsp; &#9679; &nbsp; Во всех остальных случаях точка должна быть на плоскости.</div>
<div class="caption"><img src="img/21.png" width=500><br>
in front of plane - перед плоскостью, behind plane - за плоскостью, on plane - на плоскости</div><br>
<b>Теперь можно устанавливать что вершина является выпуклой, если расстояние между ней и плоскостью больше значения эпсилон. Все остальные точки являются либо вогнутыми, либо копланарными и должны обрабатываться отдельно!</b><br><br>

<!-- Page 29 -->
<h3>Quickhull 2D: Объединение граней</h3>
Итак, что делать, при встрече с невыпуклой вершиной?
<div class=blockindent>&nbsp; &#9679; &nbsp; Правило состоит в том, чтобы каждая вершина нашей оболочки была однозначно выпуклой.</div>
<div class=blockindent>&nbsp; &#9679; &nbsp; Можно применять это правило, просто объединяя левую и правую грань через невыпуклую вершину в новую грань.</div>
<div class=blockindent>&nbsp; &#9679; &nbsp; Как можно видеть на рисунке, при этом удаляется вогнутость и исправляется геометрический дефект.</div>
<div class="caption"><img src="img/22.png" width=400><br>non-convex - невыпуклая, merged - объединенная</div><br><br>

<!-- Page 30 -->
<h3>Quickhull 2D: Значение <tt>эпсилон</tt> (&#949;)</h3>
Последний вопрос: какое значение эпсилон следует выбрать для наших "толстых" плоскостей:

<div class=blockindent>&nbsp; &#9679; &nbsp; <a href="https://docs.microsoft.com/ru-ru/cpp/c-runtime-library/floating-point-support" target="_blank" onmouseover="show('CRT - сокращ. от англ. слов C Run-time - функции среды выполнения C')" onmouseout="hide()">Функции CRT</a>
определяют значение epsilon с плавающей запятой, но при этом <b>НЕ учитываются</b> размеры нашего входного набора объектов.</div>

<div class=blockindent>&nbsp; &#9679; &nbsp; Хотелось бы определять относительный допуск принимая во внимание размер входного объекта.</div>
<div class=blockindent>&nbsp; &#9679; &nbsp; Таким образом, одно из возможных решений - выбрать значение эпсилон исходя из суммы максимальных абсолютных координат.</div>
<div class="caption"><img src="img/23.png" width=400></div>
<div class=note_trans><b>Примечание переводчика:</b> FLT_EPSILON - это разница между единицей и наименьшим значением, большим единицы, которую можно представить в виде числа с плавающей запятой.
Вот <a href="https://ru.wikipedia.org/wiki/%D0%9C%D0%B0%D1%88%D0%B8%D0%BD%D0%BD%D1%8B%D0%B9_%D0%BD%D0%BE%D0%BB%D1%8C" target="_blank">статья Википедии о машинном ноле</a> и <a href="https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Number/EPSILON" target="_blank">статья об EPSILON</a> в MDN (Mozilla Developer Network).</div>
<div class=blockindent>&nbsp; &#9679; &nbsp; Обратите внимание, что при использовании FLT_EPSILON без масштабирования мы потерпим неудачу, например, очень маленькие модели (где FLT_EPSILON намного больше, чем сама модель).</div>
<div class=blockindent>&nbsp; &#9679; &nbsp; Или для очень больших моделей, когда значение эпсилон слишком мало, чтобы иметь вообще какое-либо значение.</div><br><br>

<!-- Page 31 -->
На этом знакомство с двумерным вариантом алгоритма Quickhull заканчивается:
<div class=blockindent>&nbsp; &#9679; &nbsp; Надеюсь, что у вас появилось первое представление о работе алгоритма.</div>
<div class=blockindent>&nbsp; &#9679; &nbsp; Для двумерного пространства уже имеются хорошие алгоритмы построения выпуклых оболочек, которые легко и просто реализовать.</div>
<div class=blockindent>&nbsp; &#9679; &nbsp; Так что, если ваша игра двумерна, рекомендую использовать один из них.</div><br><br>
<hr><br>
<div class=indent1>В оставшейся части обсуждения рассмотрим, как создаются выпуклые оболочки в 3D пространстве.
<div class=list>Алгоритм Quickhull в 3D очень похож на версию, которая только что показана в описании 2D-варианта.</div>
<div class=list>Наиболее заметным отличием является построение горизонта, при этом следует более тщательно относиться к погрешностям в вычислениях.</div></div><br><hr><br><br><br>

<h1 class=head1>Quickhull 3D</h1>
<img src="img/24.png" width=250 align=right>
<h3>Quickhull 3D: Начальная оболочка</h3>
Также как и в двумерном варианте, сперва нужно построить начальную, исходную оболочку.
<div class=blockindent>&nbsp; &#9679; &nbsp; Также как это делалось в 2D, вначале нужно найти исходный треугольник <tt>(v1, v2, v3)</tt>.</div>
<div class=blockindent>&nbsp; &#9679; &nbsp; Затем, точно также добавим самую дальнюю точку от треугольной плоскости (здесь это <tt>v4</tt>).</div>
<div class=blockindent>&nbsp; &#9679; &nbsp; В 3D пространстве исходная оболочка теперь представляет собой тетраэдр.</div>
<div class=blockindent>&nbsp; &#9679; &nbsp; После построения исходной оболочки, далее разделим оставшиеся точки в списках конфликтов граней нашей исходной оболочки.</div><br><br>

<!-- Page 33 -->
<h3>Quickhull 3D: Горизонт</h3>
<div class="caption"><img src="img/25.png" width=400></div>
Затем начинаем пошагово (итеративно) добавлять к оболочке новые точки и из наших списков конфликтов определяем точку с наибольшим удалением от исходной оболочки:
<div class=blockindent>&nbsp; &#9679; &nbsp; Это даст нам следующую точку просмотра.</div>
<div class=blockindent>&nbsp; &#9679; &nbsp; Также как и в 2D варианте, снова нужно найти горизонт.</div>
<div class=blockindent>&nbsp; &#9679; &nbsp; В 3D пространстве горизонт представляет собой список ребер, которые соединяют видимые грани с невидимыми.</div>
<div class=blockindent>&nbsp; &#9679; &nbsp; И опять горизонт - это граница между видимой и невидимой частями текущей оболочки, как это видится из текущей точки просмотра.</div>

<div class=blockindent>&nbsp; &#9679; &nbsp; Finding the horizon is a bit more involved in 3D and we will look at it in more detail in just a second</div>


<!-- Page 34 -->
<h3>Quickhull 3D: Добавление точки к оболочке</h3>
Далее мы приступаем к итерации и создаем новую грань для каждого края (ребра) горизонта с новой точкой просмотра.
<div class=blockindent>&nbsp; &#9679; &nbsp; Практически, мы здесь соединяем новую вершину с текущей оболочкой.</div>
<div class=blockindent>&nbsp; &#9679; &nbsp; Наконец, мы разделяем "осиротевшие" вершины по новым граням (F1 –  F3).</div>
<div class="caption"><img src="img/26.png" width=460></div><br>

<!-- Page 35 -->
<h3>Quickhull 3D: Поиск горизонта</h3>
Найти горизонт в трехмерном пространстве не так просто, как это было при поиске двух вершин в 2D пространстве.
<div class=blockindent>&nbsp; &#9679; &nbsp; Для нахождения горизонта по существу выполняется <a href="https://ru.wikipedia.org/wiki/%D0%9F%D0%BE%D0%B8%D1%81%D0%BA_%D0%B2_%D0%B3%D0%BB%D1%83%D0%B1%D0%B8%D0%BD%D1%83" target="_blank" onmouseover="show('DFS - сокращ. англ. слов depth-first search - поиск<br>в глубину, один из методов обхода графа')" onmouseout="hide()">DFS</a>, начиная с конфликтной грани <b>S</b>.</div>
<div class=blockindent>&nbsp; &#9679; &nbsp; При каждом шаге мы пересекаем одно ребро и переходим на соседнюю, смежную грань.</div>
<div class=blockindent>&nbsp; &#9679; &nbsp; Если грань видимая, мы пересекаем другое ребро, пока не найдем грань, которая невидима из текущей точки просмотра.</div>
<div class=blockindent>&nbsp; &#9679; &nbsp; Сохраняем это обрывающееся наружу ребро как часть горизонта и продолжаем поиск в предшествующей грани.</div>
<div class=blockindent>&nbsp; &#9679; &nbsp; При завершении мы получим список всех ребер, определяющих горизонт в замкнутой петле в направлении против часовой стрелки.</div>
<div class=blockindent>&nbsp; &#9679; &nbsp; На рисунке мы начинаем от грани, помеченной как S и следуем по стрелкам, а затем возвращаемся, собирая края (ребра) горизонта.</div>
<div class=blockindent>&nbsp; &#9679; &nbsp; Поскольку это важная операция по построению оболочки, давайте рассмотрим данный шаг поподробнее.</div>
<b>Стрелки на рисунке поясняют порядок перехода по граням!</b>
<div class="caption"><img src="img/27.png" width=500></div><br><br>

<!-- Page 36 -->
<div class="caption"><img src="img/28.png" width=500></div>
Я подготовил небольшую анимацию, которая, надеюсь, поможет понять построение горизонта:<br>

<!-- Page 37 -->
<div class="caption"><img src="img/29.png" width=500></div>
<div class=blockindent>&nbsp; &#9679; &nbsp; Проверяем видимость следующей грани (и принимаем, что её видно из данной точки просмотра).</div>
<div class=blockindent>&nbsp; &#9679; &nbsp; Поскольку грань видимая, продолжаем поиск и пересекаем следующее ребро.</div>

<!-- Page 38 -->
<div class=blockindent>&nbsp; &#9679; &nbsp; Проверяем следующую грань и, поскольку она также видимая, продолжаем поиск и пересекаем следующее ребро.</div>
<div class="caption"><img src="img/30.png" width=500></div>
<!-- Page 39 -->
<div class=blockindent>&nbsp; &#9679; &nbsp; Продолжаем эти проверки до тех пор, пока не подойдем к ребру с невидимой гранью.</div>
<div class="caption"><img src="img/31.png" width=500></div>
<!-- Page 40 -->
Теперь подходим к ребру с гранью, на которой мы уже побывали.
<div class=blockindent>&nbsp; &#9679; &nbsp; Всякий раз, при посещении грани, отмечаем её как обработанную.</div>
<div class=blockindent>&nbsp; &#9679; &nbsp; Это позволяет проводить простую проверку, была ли грань обработана и её можно пропустить.</div>
<div class="caption"><img src="img/32.png" width=500></div>
<!-- Page 41 -->
Продолжаем пересекать ребра...<br>
<div class="caption"><img src="img/33.png" width=500><br>
<img src="img/34.png" width=500><br>
<img src="img/35.png" width=500><br>
<img src="img/36.png" width=500></div>
<!-- Page 45 -->
Опять встречаемся с уже посещенной гранью и поэтому не пересекаем это ребро.
<div class="caption"><img src="img/37.png" width=500></div>
<!-- Page 46 -->
<div class="caption"><img src="img/38.png" width=500><br>
<img src="img/39.png" width=500><br>
<img src="img/40.png" width=500></div>
<!-- Page 49 -->
Следующая грань также уже посещалась нами и опять здесь не нужно переходить ребро.
<div class="caption"><img src="img/41.png" width=500></div>
<!-- Page 50 -->
<div class="caption"><img src="img/42.png" width=500></div>
Наконец, мы подошли к первому ребру, которое соединяет видимую и невидимую грань.
<div class=blockindent>&nbsp; &#9679; &nbsp; Добавляем ребро в список краев (ребер) горизонта и возвращаемся к предыдущей грани.</div>
<!-- Page 51 -->
<div class="caption"><img src="img/43.png" width=500></div>
Затем переходим к следующему ребру и возвращаемся уже к предшествующей ему грани.
<!-- Page 52 -->
<div class="caption"><img src="img/44.png" width=500></div>
Снова мы подошли к ребру, соединяющему видимую и невидимую грани.
<div class=blockindent>&nbsp; &#9679; &nbsp; Сохраняем это ребро и добавляем его к нашему горизонту, а затем возвращаемся к предыдущей грани.</div>
<!-- Page 53 -->
Процедура продолжается и собирает края (ребра) горизонта, пока не возвратимся к начальной грани.
<div class="caption"><img src="img/45.png" width=500></div>
<div class="caption"><img src="img/46.png" width=500></div>
<div class="caption"><img src="img/47.png" width=500></div>
<div class="caption"><img src="img/48.png" width=500></div>
<div class="caption"><img src="img/49.png" width=500></div>
<div class="caption"><img src="img/50.png" width=500></div>
<div class="caption"><img src="img/51.png" width=500></div>
<div class="caption"><img src="img/52.png" width=500></div>
<div class="caption"><img src="img/53.png" width=500></div>
<div class="caption"><img src="img/54.png" width=500></div>
<div class="caption"><img src="img/55.png" width=500></div>
<div class="caption"><img src="img/56.png" width=500></div>
<div class="caption"><img src="img/57.png" width=500></div>
<div class="caption"><img src="img/58.png" width=500></div>
<div class="caption"><img src="img/59.png" width=500></div>
<div class="caption"><img src="img/60.png" width=500></div>
<div class="caption"><img src="img/61.png" width=500></div>
<div class="caption"><img src="img/62.png" width=500></div>
<div class="caption"><img src="img/63.png" width=500></div>
Это то ребро, с которого все начиналось и вот все готово!
<div class="caption"><img src="img/64.png" width=500></div><br>
<!-- Page 73 -->
По завершении действия мы имеем список всех ребер горизонта в направлении против часовой стрелки.
<div class="caption"><img src="img/65.png" width=500></div>
<div class=blockindent>&nbsp; &#9679; &nbsp; Теперь можно запросто создать новую треугольную грань для любого ребра горизонта нашего списка.</div>
<div class=blockindent>&nbsp; &#9679; &nbsp; По существу это будет присоединением новой вершины к текущей оболочке.</div><br>

<!-- Page 74 -->
На этом знакомство с алгоритмом Quickhull 3D завершается, а продолжается изучение инвариантов.<br><br>

<!-- Page 75 -->
<h3>Quickhull 3D: Инварианты</h3>
Как и в 2D-варианте алгоритма, при построении оболочки следует придерживаться геометрических инвариантов:
<div class="caption"><img src="img/66.png" width=500><br>на верхнем рисунке ребро <b>e</b> выпуклое, на нижнем - вогнутое</div>
<div class=blockindent>&nbsp; &#9679; &nbsp; В 3D-варианте мы также должны гарантировать, что каждое ребро оболочки является выпуклым.</div>
<div class=blockindent>&nbsp; &#9679; &nbsp; И аргументация здесь в основном такая же, что была ранее в 2D-варианте.</div>
<!-- Page 76 -->
Теперь нам нужно определить, что такое выпуклое ребро, и как можно проверить ребро на выпуклость:
<div class="caption"><img src="img/67.png" width=500><br>на верхнем рисунке - проверка левой грани, на нижнем - проверка правой грани</div>
Для каждого ребра:
<div class=blockindent>&nbsp; &#9679; &nbsp; Вначале проверяем, находится ли центр правой грани ниже плоскости левой грани.</div>
<div class=blockindent>&nbsp; &#9679; &nbsp; Затем проверяем, находится ли центр левой грани ниже плоскости правой грани.</div>
<div class=blockindent>&nbsp; &#9679; &nbsp; Если обе проверки в итоге дали значение <tt>true</tt> (истина), ребро выпуклое, в противном случае оно должно быть либо вогнутым, либо копланарным.</div>
<div class=blockindent>&nbsp; &#9679; &nbsp; Это очень похоже на проверку выпуклости в 2D-варианте, но только здесь используется центральная точка грани.</div>
<div class=blockindent>&nbsp; &#9679; &nbsp; Центр грани — это просто среднее значение от координат вершин граней.</div><br><br>

<!-- Page 77 -->
<h3>Quickhull 3D: Значение <tt>эпсилон</tt> (&#949;)</h3>
Также как и в двухмерном варианте, для алгоритма требуется значение <tt>эпсилон</tt> (&#949;), чтобы определять толщину плоских плоскостей, и мы просто расширяем нашу формулу до 3D пространства!
<div class="caption"><img src="img/68.png" width=500></div><br><br>

<!-- Page 78 -->
<h3>Quickhull 3D: Соединение копланарных граней</h3>
<div class="caption"><img src="img/69.png" width=600><br>Копланарные грани <b>F1</b> (с вершинами <b>V1</b>, <b>V2</b>, <b>V3</b>) и <b>F2</b> (с вершинами <b>V5</b>, <b>V3</b>, <b>V2</b>) объединяются в одну грань <b>F12</b> (с вершинами <b>V1</b>, <b>V2</b>, <b>V5</b>, <b>V3</b>)</div><br>
При обнаружении невыпуклого ребра, объединяем две смежные грани.
<div class=blockindent>&nbsp; &#9679; &nbsp; При этом добавляется ещё один шаг в наш пошаговый (итерационный) цикл.</div>
<div class=blockindent>&nbsp; &#9679; &nbsp; Предположим, что грани <b>face1</b> и <b>face2</b> в предыдущем примере были невыпуклыми.</div>
<div class=blockindent>&nbsp; &#9679; &nbsp; Теперь объединим <b>face1</b> и <b>face2</b> в новую полигональную грань, заменив исходные грани <b>F1</b> и <b>F2</b>.</div>
<div class=blockindent>&nbsp; &#9679; &nbsp; Как уже упоминалось в начале лекции, мы не ограничиваемся треугольными гранями.</div><br><br>

<!-- Page 79 -->
<h3>Quickhull 3D: Проблемная оболочка</h3>
Давайте теперь рассмотрим пример из оригинальной статьи Quickhull:
<div class=blockindent>&nbsp; &#9679; &nbsp; Основная идея, показанная на следующих рисунках, состоит в том, чтобы реально показать что произойдет, если не объединять грани и как можно столкнуться с кучей геометрических и топологических проблем!</div>
<div class=blockindent>&nbsp; &#9679; &nbsp; Все, что нужно понять здесь и сейчас, - объединение граней в самом деле критическая операция!</div>
<div class="caption"><img src="img/70.png" width=400><br>Ситуация: грани <b>F1</b> и <b>F3</b> видимы из новой точки <b>P</b>, а <b>F2</b> нет!</div><br>
Ситуация выглядит примерно так: грани <b>F1</b> и <b>F3</b> видимы из новой точки <b>P</b>, в то время как грань <b>F2</b> не видна!
<div class=blockindent>&nbsp; &#9679; &nbsp; Фигуру в этом примере можно рассматривать как простой тетраэдр - четырехгранник.</div>
<div class=blockindent>&nbsp; &#9679; &nbsp; Передняя грань находится в плоскости экрана и не объединена в одну большую треугольную грань, но фактически похожа на веер из трех граней.</div>
<div class=blockindent>&nbsp; &#9679; &nbsp; Нам кажется, что грани <b>F1</b> – <b>F3</b> копланарны.</div>
<div class=blockindent>&nbsp; &#9679; &nbsp; Но плохая новость в том, что копланарность существует только в идеальном мире, а не в мире чисел с ограничениями по точности!</div><br>

<!-- Page 80 -->
На самом деле происходит (и я несколько преувеличиваю здесь ситуацию) вот что:
<div class=blockindent>&nbsp; &#9679; &nbsp; Две центральные точки фактически сдвинуты внутрь.</div>
<div class=blockindent>&nbsp; &#9679; &nbsp; А ребра между <b>F1</b> и <b>F2</b>, а также <b>F2</b> и <b>F3</b> являются вогнутыми.</div>
<div class="caption"><img src="img/71.png" width=400><br>Ситуация: грани <b>F1</b> и <b>F3</b> видимы из новой точки <b>P</b>, а <b>F2</b> нет!</div><br>

<!-- Page 81 -->
Теперь давайте повернем тетраэдр и предположим, что теперь мы смотрим из-за точки <b>P</b> и снизу:
<div class=blockindent>&nbsp; &#9679; &nbsp; Надеюсь вы видите новую точку и нижние ребра трех граней.</div>
<div class=blockindent>&nbsp; &#9679; &nbsp; Из-за невыпуклости новая точка становится вроде как запертой за тремя плоскостями, что приводит к этой странной ситуации.</div>
<div class="caption"><img src="img/72.png" width=700></div><br><br>

<!-- Page 82 -->
<h3>Урезанный горизонт</h3>
Продолжим дальше и выстроим горизонт при помощи <a href="https://ru.wikipedia.org/wiki/%D0%9F%D0%BE%D0%B8%D1%81%D0%BA_%D0%B2_%D0%B3%D0%BB%D1%83%D0%B1%D0%B8%D0%BD%D1%83" target="_blank" onmouseover="show('DFS - сокращ. англ. слов depth-first search - поиск<br>в глубину, один из методов обхода графа')" onmouseout="hide()">DFS</a>, о котором узнали ранее.
<div class=blockindent>&nbsp; &#9679; &nbsp; В итоге получим пять ребер горизонта <b>a</b>, <b>b</b>, <b>c</b>, <b>d</b>, и <b>e</b>, как показано на рисунке.</div>
<div class="caption"><img src="img/73.png" width=400><br>Поиск в глубину (DFS) выдаст горизонт в направлении против часовой стрелки!</div><br><br>

<!-- Page 83 -->
<h3>Новые грани</h3>
<div class="caption"><img src="img/74.png" width=400></div>
Затем мы заменяем <b>F1</b> и <b>F3</b> пятью новыми гранями для каждого ребра <b>a</b>-<b>e</b>.
<div class=blockindent>&nbsp; &#9679; &nbsp; Поскольку результат операции довольно интересный, давайте рассмотрим каждую из новых граней по отдельности.</div>
<div class=indent1>
<h5>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Грань A</h5>
Создаем грань для ребра <b>a</b>.
<div class=blockindent>&nbsp; &#9679; &nbsp; Обратите внимание, что эта грань частично перекрывает грань <b>face2</b>, которая ещё находится на оболочке.</div>
<div class="caption"><img src="img/75.png" width=400></div>
<h3>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Грань B</h3>
Создаем грань для ребра <b>b</b>.
<div class=blockindent>&nbsp; &#9679; &nbsp; Обратите внимание, что эта грань с перевернутой ориентацией (по часовой стрелке), а также имеет общее ребро с <b>F<sub>a</sub></b>.</div>
<div class="caption"><img src="img/76.png" width=400></div>
<h3>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Грань C</h3>
Создаем грань для ребра <b>c</b>.
<div class=blockindent>&nbsp; &#9679; &nbsp; Ура, здесь ничего плохого нет.</div>
<div class="caption"><img src="img/77.png" width=400></div>
<h3>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Грань D</h3>
Создаем грань для ребра <b>d</b>.
<div class=blockindent>&nbsp; &#9679; &nbsp; Обратите внимание, эта грань снова перевернута (по часовой стрелке, как и <b>F<sub>b</sub></b>) и также имеет общее ребро с гранями <b>F<sub>a</sub></b> и <b>F<sub>b</sub></b>.</div>
<div class="caption"><img src="img/78.png" width=400></div>
<h3>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Грань E</h3>
Создаем грань для ребра <b>e</b>.
<div class=blockindent>&nbsp; &#9679; &nbsp; Вот теперь имеется уже четыре грани, которые совместно используют одну и ту же грань, а также частично перекрывающие друг друга.</div>
<div class="caption"><img src="img/79.png" width=400></div></div><br>

<!-- Page 89 -->
<h3>Грань 2</h3>
<div class="caption"><img src="img/80.png" width=500></div>
<div class=blockindent>&nbsp; &#9679; &nbsp; Из-за погрешности вычислений грань <b>face2</b> до сих пор определяется как видимая из точки <b>P</b> и будет оставаться на оболочке.</div><br><br>

<!-- Page 90 -->
<h3>Ошибки</h3>
Получилось так, что было допущено несколько серьезных ошибок, перед добавлением новой точки наша оболочка была в ненормальном состоянии.<br>
В результате новые грани нарушают ряд геометрических и топологических инвариантов:
<div class=blockindent>&nbsp; &#9679; &nbsp; Две грани (<b>F<sub>b</sub></b> и <b>F<sub>d</sub></b>) перевернуты вверх ногами (то есть, нормали этих граней направлены вовнутрь).</div>
<div class=blockindent>&nbsp; &#9679; &nbsp; У четырех граней (<b>F<sub>a</sub></b>, <b>F<sub>b</sub></b>, <b>F<sub>d</sub></b>, <b>F<sub>e</sub></b>,) имеется одно и тоже общее ребро (что делает их частично или полностью перекрывающими друг друга).</div>
Можно представить себе, что исправление этих ошибок будет довольно сложным.<br>
Хорошей новостью будет то, что при правильном соединении граней при построении оболочки я не сталкивался ни с одной из описанных проблем.<br>
Надеюсь вы увидели, как важно для надежной реализации алгоритма придерживаться правильного построения оболочки.<br><br>

<!-- Page 91 -->
<h3>Полуреберная структура (half-edge mesh)</h3>
Пока еще не было разговора о структуре данных для выпуклых многогранников. Поэтому, перед более подробным изучением объединения граней, давайте сначала рассмотрим возможную структуру данных:
<div class=blockindent>&nbsp; &#9679; &nbsp; Понятно, что существует много способов описания выпуклого многогранника.</div>
<div class=blockindent>&nbsp; &#9679; &nbsp; Обычной структурой данных является так называемая полуреберная структура данных, которая представляет собой сетку, ориентированную на ребра.</div>
<div class=blockindent>&nbsp; &#9679; &nbsp; Полуреберная структура данных упрощает итерацию (перебор) ребер грани и обращение к смежным граням.</div>
<div class="caption"><img src="img/81.png" width=500><br>Face(e) - грань e, Half-Edge e - полуребро e, Twin(e) - двойник (близнец) полуребра e,<br>
Head(e) - головная вершина полуребра e, Tail(e) - хвостовая вершина полуребра e,<br>
Prev(e) - ребро, предшествующее полуребру e, Next(e) - ребро, следующее после полуребра e</div>
Для каждой грани сохраняется:
<div class=blockindent>&nbsp; &#9679; &nbsp; Полуребро (на рисунке это полуребро <b>e</b>), которое обозначено записью в круговом списке ребер, окружающих грань.</div>
Для каждого ребра сохраняется:
<div class=blockindent>&nbsp; &#9679; &nbsp; Предыдущее (<span class="lnk" onmouseover="show('сокращ. англ. слова previous - предыдущий, предшествующий')" onmouseout="hide()">Prev</span>) и последующее (Next) ребра, которые создают круговой список ребер, окружающих грань.</div>
<div class=blockindent>&nbsp; &#9679; &nbsp; Ребро - двойник или близнец (Twin), для перехода к соседней грани.</div>
<div class=blockindent>&nbsp; &#9679; &nbsp; А также хвостовая (Tail) вершина ребра.</div>
<div class=blockindent>&nbsp; &#9679; &nbsp; Обратите внимание на то, что нам не нужно хранить головную вершину, поскольку она просто-напросто хвостовая вершина ребра-двойника.</div><br>

<!-- Page 92 -->
<h3>Объединение граней</h3>
<div class="caption"><img src="img/82.png" width=800></div>
Мы знаем, что объединение граней является важной операцией для поддержки исправности оболочки.
<div class=blockindent>&nbsp; &#9679; &nbsp; Вот пример объединения двух граней, с использованием полуреберной структуры данных.</div>
<div class=blockindent>&nbsp; &#9679; &nbsp; Ситуация заключается в том, что мы собираемся объединить левую и правую грани, поглощением левой грани правой.</div>
<div class=blockindent>&nbsp; &#9679; &nbsp; Это означает, что ребро <b>e</b> и его двойник исчезнут, а также исчезнет левая грань.</div>

<!-- Page 93 -->
<div class="caption"><img src="img/83.png" width=800></div>
Сначала удостоверяемся, что поглощающая правая грань не ссылается на удаляемое ребро (например, здесь используется <b>edge->prev</b>).
First we make sure that the absorbing right face does not reference the edge we are about to delete (e.g. we use edge->prev here)

<!-- Page 94 -->
<div class="caption"><img src="img/84.png" width=800></div>
Затем нужно убедиться, что все ребра поглощенной левой грани теперь будут ссылаться на правую сторону как на их владельца.
Next we must make sure that all edges of the absorbed left face will now reference the right face as their owner

<!-- Page 95 -->
<div class="caption"><img src="img/85.png" width=800></div>
Наконец нужно соединить входное и выходное ребра.
Finally we need to connect the incoming and outgoing edges

<div class=blockindent>&nbsp; &#9679; &nbsp; Также обратите внимание, что получить доступ ко всем необходимым данным для операции слияния можно только из общего ребра между двумя соседними гранями, которые мы собираемся объединить
Also note that we can access all necessary data for the merge operation just from the shared edge between the two adjacent faces we are about to merge</div><br>

<!-- Page 96 -->
В результате объединения двух граней появляется полигональная грань со своими, не совсем копланарными вершинами.
<div class=blockindent>&nbsp; &#9679; &nbsp; Помните, что мы находимся в мире с ограниченной точностью вычислений.</div>

<div class=blockindent>&nbsp; &#9679; &nbsp; <a href="https://en.wikipedia.org/wiki/Newell%27s_algorithm" target="_blank">Алгоритм Ньюэлла</a> (<a href="https://en.wikipedia.org/wiki/Newell%27s_algorithm" target="_blank">Newell's algorithm</a>) строит наилучшую соответствующую плоскость в смысле наименьшего квадрата, которая минимизирует расстояние до вершин
The Newell algorithm builds a best fit plane in the least square sense which minimizes the distance of the vertices</div>

<div class=note_trans>Чуть подробнее об алгоритме Ньюэла − Ньюэла − Санча <a class='link' onclick='javascript:spoiler(this)'>... читать далее</a>
<div style='display:none;'>Рассмотрим далее алгоритм удаления невидимых граней методом сортировки по глубине (авторы: Ньюэлл, Ньюэлл, Санча). Часть этого метода работает в пространстве объекта, а часть в пространстве изображения. Он также работает для параллельной проекции, то есть с учетом того, что произведено перспективное преобразование. Введем определение пространственной оболочки.<br>
Пространственной оболочкой трехмерного объекта называется минимальный прямоугольный параллелепипед, целиком содержащий внутри себя данный объект. Аналогично можно определить двумерную и одномерную пространственные оболочки.<br>
Метод состоит из трех основных шагов:<br>
<div class=list>1. Упорядочение всех многоугольников в соответствии с их наибольшими z-координатами.</div>
<div class=list>2. Разрешение всех неопределенностей, которые возникают при перекрытии z-оболочек многоугольников.</div>
<div class=list>3. Преобразование каждого из многоугольников в растровую форму, производимое в порядке уменьшения их наибольшей z-координаты.</div>
Ближайшие многоугольники преобразуются в растровую форму последними и закрывают более отдаленные многоугольники, так как изображаются поверх предыдущих.<br><br>
<span style='float:right; margin-top:-16px; background-color:#ffffe8;'><em>(<a href='http://www.astro.tsu.ru/KGaG/text/5_6_k2.html' target='_blank'>извотздесь</a>)</em>&nbsp;&nbsp;&nbsp;</span></div></div>

<!-- Page 97 -->
Для удобства и завершенности здесь добавлено несколько формул, но переход на подробности несколько отвлечет нас от темы.
<div class=blockindent>&nbsp; &#9679; &nbsp; Книги от <a href="https://www.amazon.com/Collision-Detection-Interactive-Environments-Technology/dp/155860801X" target="_blank">Gino Van Den Bergen</a>
и <a href="http://realtimecollisiondetection.net/books/rtcd/" target="_blank">Christer Ericson</a> охватывают плоскости Ньюелла, а также в список <a href="#ref">литературы, рекомендуемой к прочтению,</a> добавлены дополнительные ссылки</div>
<div class="caption"><img src="img/86.png" width=250></div><br><br>

<!-- Page 98 --><img src="img/87.png" width=200 align=right>
<h3>Топологические инварианты</h3>
Теперь давайте посмотрим на один важный топологический инвариант выпуклой оболочки.
<div class=blockindent>&nbsp; &#9679; &nbsp; Самое главное для нас состоит в том, что каждая вершина должна иметь по крайней мере три смежные грани.</div>
<div class=blockindent>&nbsp; &#9679; &nbsp; Если оболочка не удовлетворяет этому инварианту, то она имеет так называемую, вершинную избыточность.</div>
Конечно, существуют и другие топологические инварианты, такие как:
<div class=blockindent>&nbsp; &#9679; &nbsp; Каждая грань должна иметь не менее трех соседних граней.</div>
<div class=blockindent>&nbsp; &#9679; &nbsp; Каждое ребро является общим только для двух граней.</div>
<div class=blockindent>&nbsp; &#9679; &nbsp; Каждая грань выпуклого многогранника должна быть выпуклым многоугольником (полигоном).</div>
Но, как выясняется, нам не нужно иметь дело с ними непосредственно.<br><br>

<!-- Page 99 -->
<h3>Исправление топологических ошибок</h3>
При объединении граней можно попасть в ситуацию, неудовлетворяющую топологическим инвариантам, и должны исправить её:
<div class="caption"><img src="img/88.png" width=600></div>
Рассмотрим последовательность объединения на приведенном выше рисунке и то, как это может привести к топологическим ошибкам:
<div class=blockindent>&nbsp; &#9679; &nbsp; Мы "сливаем" грань <b>face1</b> в <b>face3</b>.</div>
При этом появляется пара проблем:
<div class=blockindent>&nbsp; &#9679; &nbsp; Вершина <b>v</b> теперь имеет только две смежные грани и стала избыточной.</div>
<div class=blockindent>&nbsp; &#9679; &nbsp; Грань <b>Face2</b> имеет только две смежных грани.</div>
<div class=blockindent>&nbsp; &#9679; &nbsp; Грань <b>Face13</b> не выпуклая.</div>

<!-- Page 100 -->
<div class="caption"><img src="img/89.png" width=600></div>
Данная ошибка обнаруживается с помощью проверки смежных граней для входного (<b>e<sub>in</sub></b>) и выходного (<b>e<sub>out</sub></b>) ребер -><br>
Оба ребра указывают на <b>face2</b>.
<div class=blockindent>&nbsp; &#9679; &nbsp; Поскольку <b>face2</b> - это треугольник, мы не будем соединять входное (<b>e<sub>in</sub></b>) и выходное (<b>e<sub>out</sub></b>) ребра, но взамен будем использовать ребро, не используемое совместно.
Since face2 is a triangle we will not connect the in- and outgoing edge, but use the non-shared edge instead</div>

<div class=blockindent>&nbsp; &#9679; &nbsp; Обратите внимание, что грань <b>face2</b> стала избыточной, так как все вершины содержатся в <b>face13</b>, и может быть удалена.</div>
<div class=blockindent>&nbsp; &#9679; &nbsp; Кроме того, и вершина <b>v</b> стала ненужной, и также будет удалена.</div>
Трюк здесь в том, что при объединении двух граней, мы делаем проверку на появление этой ошибки и, если она существует, сразу же её исправляем!<br>

<!-- Page 101 -->
<div class="caption"><img src="img/90.png" width=600></div>
Давайте ещё раз взглянем на предыдущий пример.<br>
Рассмотрим теперь несколько другую последовательность слияния:
<div class=blockindent>&nbsp; &#9679; &nbsp; Теперь сливаем грань <b>face2</b> в грань <b>face1</b>.</div>
Снова:
<div class=blockindent>&nbsp; &#9679; &nbsp; Вершина <b>v</b> теперь имеет только две смежные грани и стала избыточной.</div>
В этом случае никакой другой проблемы, кроме этой, здесь не усматривается.

<!-- Page 102 -->
<div class="caption"><img src="img/91.png" width=600></div>
We detect this error again by checking the adjacent faces of the in- and outgoing edges -> Здесь оба ребра указывают на грань <b>face3</b>.

<div class=blockindent>&nbsp; &#9679; &nbsp; Since face3 has now more than three vertices we cannot apply the same fixing strategy as before</div>

<div class=blockindent>&nbsp; &#9679; &nbsp; Instead we simply extend the incoming edge to the next vertex and delete the outgoing edge</div>

<div class=blockindent>&nbsp; &#9679; &nbsp; Again vertex v has become obsolete and should be deleted as well</div>
Снова, при объединении двух граней делаем проверку на появление этой ошибки и, если она существует, сразу же её исправляем!

<!-- Page 103 -->
<h3>Большие циклы объединения</h3>
Другая проблема, с которой можно столкнуться при объединении граней, состоит в том, что может быть добавлено большое количество новых граней, которые нужно объединить:
<div class=blockindent>&nbsp; &#9679; &nbsp; Давайте назовем это циклом слияния (merge cycle).</div>
<div class="caption"><img src="img/92.png" width=800></div>
Представьте себе, что мы создаем выпуклую оболочку цилиндра, и собираемся добавить последнюю вершину верхней грани:
<div class=blockindent>&nbsp; &#9679; &nbsp; Разумеется, эта вершина находится в той же плоскости, что и другие вершины.</div>
<div class=blockindent>&nbsp; &#9679; &nbsp; В этой ситуации мы создаем много новых граней, которые примерно копланарны и должны быть объединены.</div>
<div class=blockindent>&nbsp; &#9679; &nbsp; В идеале хотелось бы объединить все новые грани в одну, как показано на рисунке справа.</div>

<!-- Page 104 -->
<div class="caption"><img src="img/93.png" width=400></div>
Проблема в том, что практически "сливается" одна грань за другой:
The problem is now that we practically merge one face after the other:

<div class=blockindent>&nbsp; &#9679; &nbsp; Всякий раз, при объединении двух граней, перестраивается плоскость грани.</div>
<div class=blockindent>&nbsp; &#9679; &nbsp; Перестроение грани может смещать плоскость и ребро между двумя гранями может временно стать выпуклым и не позволит нам объединить весь круг целиком.</div>

<div class=blockindent>&nbsp; &#9679; &nbsp; В наихудшем случае это может привести к вогнутым граням, которые теперь должным образом <b>НЕ</b> объединены.
In the worst case this can introduce concave faces which are now NOT merged properly</div>

Вот несколько идей по решению этой проблемы:
<div class=blockindent>&nbsp; &#9679; &nbsp; Грани с наибольшей площадью должны быть наиболее устойчивыми по отношению к ориентации плоскости грани. Таким образом, первоочередное слияние в самые большие грани уменьшает смещение.</div>
<div class=blockindent>&nbsp; &#9679; &nbsp; Можно также ввести абсолютное допустимое отклонение для увеличения предела слияния и сделать цикл слияния менее чувствительным для этих ситуаций.</div>
Это в основном то, как я справляюсь с этой проблемой на данный момент, поскольку для физики желательны грани как можно большего размера по соображениям стабильности и нет стремления к наиболее плотно прилегающей оболочке.<br>
Если ведется работа с полями столкновений, то вероятно неплохо сделать это абсолютное допустимое отклонение небольшим процентом от этого поля.<br><br>

<!-- Page 105 -->
Еще одна идея для решения этой проблемы - при объединении граней вообще <b>НЕ</b> перестраивать плоскости граней:
Another idea to deal with this problem is to NOT rebuild the face planes at all when merging to faces:
<div class="caption"><img src="img/94.png" width=600><br>face plane - плоскость грани</div>
<div class=blockindent>&nbsp; &#9679; &nbsp; Для обеих граней у вас есть наиболее подходящая плоскость и вершины (которые я и попытался изобразить на рисунке).</div>

<div class=blockindent>&nbsp; &#9679; &nbsp; Теперь можно вычислить абсолютное расстояние вершин правой грани до плоскости левой грани и наоборот.
We can now compute the absolute distance of the right face’s vertices to the left face’s plane and vice versa</div>

<div class=blockindent>&nbsp; &#9679; &nbsp; Затем просто сохраняем плоскость грани, которая минимизирует расстояние, вместо её перестраивания.
Then we simply keep the face plane that minimizes the distance instead of rebuilding it</div>

<!-- Page 106 -->
Давайте закончим эту часть, о том как можно использовать слияние граней для борьбы с дефектными оболочками:
Let’s close this part how we could use face merging to deal with defect hulls:

<div class=blockindent>&nbsp; &#9679; &nbsp; На каждой итерации основное предположение состоит в том, чтобы начать с исправной оболочки.
At each iteration the basic assumption is to start with a healthy hull</div>

<div class=blockindent>&nbsp; &#9679; &nbsp; При добавлении вершины необходимо проверить все новые грани на наличие возможных дефектов на ребрах между ними и на горизонте.
When adding the vertex we need to inspect all new faces for possible defects at their edges between each other and at the horizon</div>

<div class=blockindent>&nbsp; &#9679; &nbsp; Это слабые места, где могут возникнуть новые ошибки.
These are the weak spots where might have introduced new errors</div>

<div class=blockindent>&nbsp; &#9679; &nbsp; Простая стратегия состоит в переборе всех новых граней и поочередном исправлении каждого ребра, одного за другим.
An easy strategy is to iterate all new faces and repair each edge one by one</div><br><br>

<!-- Page 107 -->
Это закрывает теорию, и в оставшейся части этого разговора я хотел бы поделиться некоторыми быстрыми советами о возможной реализации
This closes the theory and in the remainder of this talk I like to share some quick tips about a possible implementation<br><br>

<!-- Page 108 -->
Основной ловушкой для производительности является плохое управление памятью полуреберной структуры данных:
The major performance pitfall is bad memory management of the half-edge data structure:

<div class=blockindent>&nbsp; &#9679; &nbsp; Выпуклая оболочка для <b>N</b> вершин ограничена
The convex hull for N vertices is bounded</div>

<div class=blockindent>&nbsp; &#9679; &nbsp; Наихудшим случаем является тот, у которого все входные вершины находятся на оболочке: Worst case is that all input vertices are on the hull:</div>

<div class=blockindent>&nbsp; &#9679; &nbsp; Число вершин тогда не более V = N. The number of vertices is then at most V = N</div>

<div class=blockindent>&nbsp; &#9679; &nbsp; Число ребер тогда не более E = 3N - 6. The number of edges is then at most E = 3N – 6</div>

<div class=blockindent>&nbsp; &#9679; &nbsp; Число граней тогда не более F = 2N - 4. The number of faces is then at most F = 2N – 4</div>

<div class=blockindent>&nbsp; &#9679; &nbsp; Проверка по формуле Эйлера: V - E + F = 2. Test with Euler’s formula: V –  E + F = 2</div><br><br>


В нашей реализации можно предварительно выделить один буфер для вершин, полуребер и граней и управлять этим буфером в свободном списке.
In our implementation we can pre-allocate one buffer for vertices, half-edges, and faces and manage this buffer in a free list

<div class=blockindent>&nbsp; &#9679; &nbsp; В идеале у нас будет только одно большое назначение на конструкцию оболочки! Ideally we will just have one big allocation per hull construction!</div>

<div class=blockindent>&nbsp; &#9679; &nbsp; Это становится особенно важным, если планируется вычислять выпуклые оболочки во время выполнения (например, для разрушения).
This becomes especially important if you plan to compute convex hulls at runtime (e.g. for destruction)</div><br><br>

Вот некоторые практические детали:
Here are some practical details:
<div class=blockindent>&nbsp; &#9679; &nbsp; Не забывайте, что нужно назначать полуребра (которых вдвое больше, чем ребер).
Don’t forget that you need to allocate half-edges (which is twice the number of edges)</div>

<div class=blockindent>&nbsp; &#9679; &nbsp; Также необходимо учитывать временные назначения (например, грани горизонта).
We also need to account for temporary allocations (e.g. horizon faces)</div>

<div class=blockindent>&nbsp; &#9679; &nbsp; На практике я просто удваиваю размер буфера. In practice I just double the buffer size</div>

<!-- Page 109 -->
<h3>Реализация: полуреберная сетка</h3>
<pre>struct qhVertex
{
  qhVertex * Prev;
  qhVertex * Next;<br>
  // Optional (дополнительно)
  qhHalfEdge* Edge;<br>
  qhVector3 Position;
};</pre>
Давайте начнем со структуры вершин.
<div class=blockindent>&nbsp; &#9679; &nbsp; Для хранения вершин я пользуюсь <a href="https://ru.wikipedia.org/wiki/%D0%98%D0%BD%D1%82%D1%80%D1%83%D0%B7%D0%B8%D0%B2%D0%BD%D1%8B%D0%B9_%D1%81%D0%BF%D0%B8%D1%81%D0%BE%D0%BA" target="_blank" onmouseover="show('Интрузивный список — это такой список, в котором каждый элемент<br>содержит ссылки на соседей. Другими словами, элементы в таком<br>списке «имеют представление» о том, что находятся в списке и своем<br>положении в нем, тогда как в обычном списке данные и информация<br>о соседних элементах изолированы друг от друга.')" onmouseout="hide()">интрузивным списком</a>.</div>
<div class=blockindent>&nbsp; &#9679; &nbsp; Вершины находятся либо на оболочке, либо в списке конфликтов.</div>

<div class=blockindent>&nbsp; &#9679; &nbsp; Поэтому, естественно, мы должны включить сюда указатели списка. So obviously we have to include the list pointers here.</div>

<div class=blockindent>&nbsp; &#9679; &nbsp; При желании можно также сохранить ребро, оставляющее вершину.
We can optionally also store an edge leaving the vertex.</div>

<div class=blockindent>&nbsp; &#9679; &nbsp; Это не требуется для построения оболочки, но может быть полезно для последующей обработки, если вам понадобится, например, для итерации всех смежных граней вершины.
This is not needed for constructing the hull, but it can be useful for post-processing if you like e.g. to iterate all adjacent faces of the vertex</div>

<div class=blockindent>&nbsp; &#9679; &nbsp; Конечно, также нужно сохранять положение вершины.</div>

<!-- Page 110 -->
<pre>struct qhHalfEdge
{
  qhVertex* Tail;<br>
  qhHalfEdge* Prev;
  qhHalfEdge* Next;
  qhHalfEdge* Twin;<br>
  qhFace* Face;
};</pre>
Теперь давайте глянем, как можно реализовать полуребро:
Now let’s have a quick look how we can potentially implement a half-edge:

<div class=blockindent>&nbsp; &#9679; &nbsp; Как и следовало ожидать, это определение непосредственно сопоставляется с возможной структурой данных.
As we would expect this definition maps pretty directly to a possible data structure</div>

<div class=blockindent>&nbsp; &#9679; &nbsp; Мы сохраняем указатель на хвостовую вершину ребра.</div>

<div class=blockindent>&nbsp; &#9679; &nbsp; Полуребра создают круговой список вокруг грани, поэтому здесь также нужно сохранить указатели списка.
The half-edges build a circular list around the face so we also need to store the list pointers here</div>

<div class=blockindent>&nbsp; &#9679; &nbsp; И, конечно же, также сохраняем ребро-двойник, для перехода к соседней грани.</div>
<div class=blockindent>&nbsp; &#9679; &nbsp; Наконец, также сохраняем ссылку на родительскую грань ребра.</div>


<!-- Page 111 -->
<pre>struct qhFace
{
  qhFace* Prev;
  qhFace* Next;<br>
  qhHalfEdge* Edge;
  qhList&lt; qhVertex > ConflictList;
};</pre>
Наконец, структура граней:

<div class=blockindent>&nbsp; &#9679; &nbsp; I am also using an intrusive list here, so we have to include the list pointers again</div>

<div class=blockindent>&nbsp; &#9679; &nbsp; And of course there is a pointer to the first edge starting the circular list around the face</div>

<div class=blockindent>&nbsp; &#9679; &nbsp; Finally it is possibly a good idea to store our conflict list here as well</div>


<!-- Page 112 -->
<h3>Реализация: построение (construction)</h3>
<pre>void qhConvex::Construct( const qhArray&lt; qhVector3 >& Vertices )
{
  if ( !BuildlnitialHull( Vertices) )
    return;<br>
  qhVertex* Vertex = NextConflictVertex();
  while ( Vertex != NULL )
  {
    AddVertexToHull( Vertex );
    Vertex = NextConflictVertex();
  }
};</pre>
Finally some high-level code examples to give you an idea of a possible implementation:

<div class=blockindent>&nbsp; &#9679; &nbsp; Assume we have some qhConvex class to store the hull after construction</div>

<div class=blockindent>&nbsp; &#9679; &nbsp; This snippet shows the top level construction function</div>

Explain a bit…

<!-- Page 113 -->
<h3>Реализация: повторение (iteration)</h3>
<pre>void qhConvex::AddVertex( const qhVertex* Vertex )
{
  qhArray&lt; qhHalfEdge* > Horizon;
  BuildHorizion( Horizon );<br>
  qhArray&lt; qhFace* > NewFaces;
  BuildNewFaces( NewFaces, Horizon );
  MergeFaces( NewFaces );<br>
  ResolveOrphans( NewFaces );
};</pre>
The code snippets shows the iterative AddVertex() function

<div class=blockindent>&nbsp; &#9679; &nbsp; We add new points until our conflict lists are empty</div>

Explain a bit…

<!-- Page 114 -->
So you want to implement Qhull yourself and I talked now for nearly an hour and there is no code!

<div class=blockindent>&nbsp; &#9679; &nbsp; Luckily there is a beautiful open-source implementation in JAVA which you can use to start</div>

<div class=blockindent>&nbsp; &#9679; &nbsp; I also recommend looking at the original Qhull implementation which is not only a great implementation, but also full of gems of computational geometry!!!</div>

This closes the talk and hopefully my presentation will help you to understand and implement a robust convex hull builder!

Thank you!<br><br>

<h1 class=head1 id="ref">Литература</h1>
Описание алгоритма Quickhull:
<div class=blockindent><a href="http://dpd.cs.princeton.edu/Papers/BarberDobkinHuhdanpaa.pdf" target="_blank">C. Barber/D. Dobkin: "The Quickhull Algorithm for Convex Hulls"</a><br>
R. Seidel: "Small Dimensional Linear Programming and Convex Hulls Made Easy"<br>
J. Smith: "Quickhull 3D"</div>
Книги:
<div class=blockindent><a href="https://www.amazon.com/Collision-Detection-Interactive-Environments-Technology/dp/155860801X" target="_blank">G. v. d. Bergen: "Collision Detection in Interactive 3D Environments"</a><br>
<a href="http://realtimecollisiondetection.net/books/rtcd/" target="_blank">C. Ericson: "Real-time Collision Detection"</a><br>
J. O'Rourke: "Computational Geometry in C"<br>
M. de Berg: "Computational Geometry"<br>
E. Langetepe: "Geometric Data Structures for Computer Graphics"</div>
Публикации на смежные темы:
<div class=blockindent>G. Rhodes: "Computational Geometry" (Half-Edge Mesh)<br>
M. McGuire: "The Half-Edge Data Structure" (Half-Edge Mesh)<br>
D. Gordon: "Computing the Plane Equation of a Polygon" (Newell Plane)<br>
E. Catto: "A Troublesome Triangle" (Newell Plane)<br>
S. Melax: "Interaction with 3D Geometry" (StanHull)</div>
Статьи о вычислениях с плавающей запятой:
<div class=blockindent><a href="http://randomascii.wordpress.com/categorv/floating-point/" target="_blank">B. Dawson: http://randomascii.wordpress.com/categorv/floating-point/</a><br>
<a href="http://realtimecollisiondetection.net/pubs/Tolerances/" target="_blank">C. Ericson: http://realtimecollisiondetection.net/pubs/Tolerances/</a></div>
<br><br>

<h1 class=head1>Благодарность</h1>
Прежде чем закончить, хочется выразить благодарность целой куче народа!
<div class=blockindent>&nbsp; &#9679; &nbsp; Thanks to Valve for giving me permission to present to you today</div>
<div class=blockindent>&nbsp; &#9679; &nbsp; Thanks to Paul, Steve, Jeff and Anoush for spending time and rehearse this presentation with me</div>
<div class=blockindent>&nbsp; &#9679; &nbsp; Thanks to Randy for reading the presentation several times at an early stage and providing valuable feedback</div>
<div class=blockindent>&nbsp; &#9679; &nbsp; Special thanks to Bruce Dawson for helping with the numerical problems in Quickhull and also providing all kinds of other valuable feedback</div>
<div class=blockindent>&nbsp; &#9679; &nbsp; Special thanks to John Lloyd for sharing his beautiful JAVA Quickhull implementation and making it open source</div>
If you liked this talk and if you want to see more cool Valve presentations please visit out website!

<br><br>
</body></html>
